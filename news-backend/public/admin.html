<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InfoCloud Backend Manager</title>
    <style>
        :root {
            --bg-color: #0D0D0D; /* Very dark grey / off-black */
            --text-color: #C0C0C0; /* Light grey */
            --primary-accent-color: #00FF00; /* Bright Green */
            --secondary-accent-color: #00A000; /* Darker Green */
            --border-color: #2A2A2A; /* Dark grey for borders */
            --error-color: #FF3333; /* Bright Red */
            --warning-color: #FFFF00; /* Bright Yellow */
            --input-bg-color: #1A1A1A;
            --button-bg-color: #222222;
            --button-hover-bg-color: #333333;
            --header-bg-color: #1A1A1A;
            --content-bg-color: #101010;

            --font-family-monospace: "Menlo", "Monaco", "Consolas", "Liberation Mono", "Courier New", monospace;
            --font-family-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;

            --padding-tight: 4px;
            --padding-normal: 8px;
            --padding-loose: 12px;

            --border-radius-sharp: 0px;
            --border-width: 1px;

            --font-size-small: 12px;
            --font-size-normal: 14px;
            --font-size-large: 16px;
            --font-size-xl: 20px;
            --line-height: 1.4;
        }

        body {
            font-family: var(--font-family-monospace);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: var(--padding-loose);
            font-size: var(--font-size-normal);
            line-height: var(--line-height);
        }

        .ascii-header {
            font-family: var(--font-family-monospace);
            color: var(--primary-accent-color);
            white-space: pre;
            text-align: center;
            font-size: 10px; /* Smaller for ASCII art */
            line-height: 1.1;
            padding: var(--padding-normal) 0;
            background-color: var(--bg-color); /* Match body or slightly different */
            border-bottom: var(--border-width) solid var(--border-color);
            margin-bottom: var(--padding-loose);
        }

        .manager-container {
            display: flex;
            flex-direction: column;
            gap: var(--padding-loose);
        }
        
        .main-content-area {
            display: flex;
            flex-direction: row; /* For side-by-side layout */
            gap: var(--padding-loose);
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .left-column {
            flex: 2; /* Takes 2/3 of the space */
            display: flex;
            flex-direction: column;
            gap: var(--padding-loose);
            min-width: 300px; /* Minimum width before wrapping */
        }

        .right-column {
            flex: 1; /* Takes 1/3 of the space */
            display: flex;
            flex-direction: column;
            gap: var(--padding-loose);
            min-width: 250px; /* Minimum width before wrapping */
        }

        .panel {
            background-color: var(--content-bg-color);
            border: var(--border-width) solid var(--border-color);
            border-radius: var(--border-radius-sharp);
            padding: var(--padding-normal);
        }

        .panel-header {
            font-size: var(--font-size-large);
            color: var(--primary-accent-color);
            margin: 0 0 var(--padding-normal) 0;
            padding-bottom: var(--padding-tight);
            border-bottom: var(--border-width) solid var(--secondary-accent-color);
            font-weight: normal;
        }

        /* Status Panel Styles */
        #status-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--padding-normal);
        }

        .status-item {
            background-color: var(--input-bg-color);
            padding: var(--padding-tight) var(--padding-normal);
            border: var(--border-width) solid var(--border-color);
            border-radius: var(--border-radius-sharp);
            display: flex;
            align-items: center;
            gap: var(--padding-tight);
            font-size: var(--font-size-small);
        }

        .status-light {
            width: 10px;
            height: 10px;
            border-radius: var(--border-radius-sharp); /* Square lights */
            margin-right: var(--padding-tight);
            background-color: #444; /* Default off */
            flex-shrink: 0;
            border: 1px solid #555; /* Subtle border for the light */
        }

        .status-light.status-good { background-color: var(--primary-accent-color); }
        .status-light.status-warning { background-color: var(--warning-color); }
        .status-light.status-bad { background-color: var(--error-color); }
        .status-light.status-off { background-color: #333; }


        /* LLM Selector & DB Actions */
        .system-controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--padding-normal);
            margin-bottom: var(--padding-normal);
        }

        .llm-selector-container, #db-actions-container {
            background-color: var(--input-bg-color);
            padding: var(--padding-tight) var(--padding-normal); /* Reduced padding */
            border: var(--border-width) solid var(--border-color);
            border-radius: var(--border-radius-sharp);
            display: flex; /* Added for horizontal layout */
            align-items: center; /* Vertically align items */
            gap: var(--padding-tight); /* Space between items */
        }
        .llm-selector-container label {
            margin-bottom: 0; /* Remove bottom margin from label */
            margin-right: var(--padding-tight);
            white-space: nowrap;
        }
        .llm-selector-container select {
            flex-grow: 1; /* Allow select to take available space */
            margin-bottom: 0; /* Remove bottom margin if any from global styles */
        }
         #db-actions-container h3 {
            color: var(--primary-accent-color);
            font-size: var(--font-size-normal);
            margin: 0 var(--padding-normal) 0 0; /* Adjust margin */
            padding-bottom: 0; /* Remove padding */
            border-bottom: none; /* Remove border */
            white-space: nowrap;
         }
         #db-actions-container button {
            margin-left: var(--padding-tight); /* Add some space between buttons */
         }
         #dbActionStatus {
            width: 100%; /* Make status take full width below */
            text-align: left; /* Align to left below buttons */
            margin-top: var(--padding-tight);
            font-size: var(--font-size-small);
            flex-basis: 100%; /* Ensure it wraps to the next line */
         }


        /* Accordion Styles */
        .accordion-section {
            background-color: var(--content-bg-color);
            border: var(--border-width) solid var(--border-color);
            border-radius: var(--border-radius-sharp);
            margin-bottom: var(--padding-normal); /* Keep some separation */
        }

        .accordion-header {
            background-color: var(--header-bg-color);
            color: var(--primary-accent-color);
            cursor: pointer;
            padding: var(--padding-normal);
            border: none; /* Remove default border */
            border-bottom: var(--border-width) solid var(--border-color); /* Border for separation */
            text-align: left;
            outline: none;
            font-size: var(--font-size-large);
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: normal;
        }
        .accordion-header:hover {
            background-color: var(--secondary-accent-color);
            color: var(--bg-color);
        }
        .accordion-header .arrow {
           font-size: var(--font-size-normal);
           margin-left: var(--padding-tight);
           transition: transform 0.2s ease-in-out;
        }
        .accordion-header.active .arrow { transform: rotate(90deg); }
        .accordion-content {
            padding: var(--padding-normal);
            background-color: var(--content-bg-color); /* Slightly different or same as panel */
            max-height: 0;
            overflow-y: auto; /* Changed to auto for scroll if content is too long */
            overflow-x: hidden;
            transition: max-height 0.2s ease-out;
            border-top: none; /* No top border as header has bottom */
        }
        .accordion-content.active {
            /* max-height will be set by JS */
        }


        /* DB Stats Visualization */
        #dbStats .stat-item, #tagStats .stat-item, #biasStats .stat-item, #categoryStats .stat-item {
            margin-bottom: var(--padding-tight);
            font-size: var(--font-size-small);
        }
        #dbStats .stat-item strong, #tagStats .stat-item strong, #biasStats .stat-item strong, #categoryStats .stat-item strong {
            color: var(--primary-accent-color);
            min-width: 150px; /* Align keys */
            display: inline-block;
        }
        /* Basic bar for LLM Fallback */
        .stat-bar-container {
            background-color: var(--border-color);
            height: 10px;
            width: 100px;
            display: inline-block;
            border-radius: var(--border-radius-sharp);
            overflow: hidden;
            margin-left: var(--padding-tight);
        }
        .stat-bar {
            background-color: var(--primary-accent-color);
            height: 100%;
            width: 0%; /* Set by JS or defaults */
            border-radius: var(--border-radius-sharp);
        }
         .stat-bar.warning { background-color: var(--warning-color); }
         .stat-bar.error { background-color: var(--error-color); }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: var(--font-size-small);
        }
        th, td {
            border: var(--border-width) solid var(--border-color);
            padding: var(--padding-tight);
            text-align: left;
            vertical-align: top; /* Better for multi-line content in cells */
        }
        /* Add this for tighter select padding */
        #sourcesTable select {
            padding-top: 1px;
            padding-bottom: 1px;
            font-size: calc(var(--font-size-small) - 1px); /* Slightly smaller font for selects */
        }
        th {
            background-color: var(--header-bg-color);
            color: var(--primary-accent-color);
            font-weight: normal;
        }
        th.sortable-header {
            cursor: pointer;
        }
        th.sortable-header:hover {
            background-color: var(--secondary-accent-color);
            color: var(--bg-color);
        }
        th .sort-arrow {
            float: right;
            font-size: 0.8em;
            margin-left: 5px;
        }
        th .sort-arrow.asc::after { content: ' ▲'; }
        th .sort-arrow.desc::after { content: ' ▼'; }

        tbody tr:nth-child(odd) {
            background-color: var(--input-bg-color); /* Subtle striping */
        }
        tbody tr:hover {
            background-color: var(--secondary-accent-color);
            color: var(--bg-color);
        }

        /* Form Elements */
        input[type="text"], input[type="url"], input[type="number"], select, textarea {
            background-color: var(--input-bg-color);
            color: var(--text-color);
            border: var(--border-width) solid var(--border-color);
            border-radius: var(--border-radius-sharp);
            padding: var(--padding-tight);
            font-family: var(--font-family-monospace);
            font-size: var(--font-size-normal);
            width: calc(100% - 10px); /* Adjust for padding */
            margin-bottom: var(--padding-tight);
        }
        input[type="text"]:focus, input[type="url"]:focus, input[type="number"]:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-accent-color);
            box-shadow: 0 0 3px var(--primary-accent-color);
        }
        button, input[type="submit"] {
            background-color: var(--button-bg-color);
            color: var(--primary-accent-color);
            border: var(--border-width) solid var(--secondary-accent-color);
            border-radius: var(--border-radius-sharp);
            padding: var(--padding-tight) var(--padding-normal);
            cursor: pointer;
            font-family: var(--font-family-monospace);
            font-size: var(--font-size-normal);
            transition: background-color 0.2s, color 0.2s;
        }
        button:hover, input[type="submit"]:hover {
            background-color: var(--primary-accent-color);
            color: var(--bg-color);
        }
        button:disabled {
            background-color: #222;
            color: #555;
            border-color: #333;
            cursor: not-allowed;
        }
        label {
            display: block;
            margin-bottom: var(--padding-tight);
            font-size: var(--font-size-small);
        }
        
        /* Utility classes */
        .hidden { display: none; }
        .text-center { text-align: center; }
        .mt-1 { margin-top: var(--padding-normal); }
        .mb-1 { margin-bottom: var(--padding-normal); }
        .error-message { color: var(--error-color); font-size: var(--font-size-small); }
        .success-message { color: var(--primary-accent-color); font-size: var(--font-size-small); }
        
        /* Toast Notification */
        #toast-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--input-bg-color);
            color: var(--text-color);
            padding: var(--padding-normal) var(--padding-loose);
            border-radius: var(--border-radius-sharp);
            border: var(--border-width) solid var(--border-color);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            z-index: 1000;
            font-size: var(--font-size-normal);
            opacity: 0;
            transition: opacity 0.3s ease, bottom 0.3s ease;
            visibility: hidden;
        }
        #toast-notification.show {
            opacity: 1;
            bottom: 30px;
            visibility: visible;
        }
        #toast-notification.success { border-left: 5px solid var(--primary-accent-color); }
        #toast-notification.error { border-left: 5px solid var(--error-color); }
        #toast-notification.warning { border-left: 5px solid var(--warning-color); }

        /* Modal styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; 
            z-index: 1001; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
        }

        .modal-content {
            background-color: var(--content-bg-color);
            margin: 10% auto; /* 10% from the top and centered */
            padding: var(--padding-loose);
            border: var(--border-width) solid var(--primary-accent-color);
            border-radius: var(--border-radius-sharp);
            width: 80%; /* Could be more or less, depending on screen size */
            max-width: 600px; /* Maximum width */
            color: var(--text-color);
        }
        .modal-content h2 {
            color: var(--primary-accent-color);
            font-size: var(--font-size-large);
            margin-top:0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: var(--padding-normal);
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close-button:hover,
        .close-button:focus {
            color: var(--primary-accent-color);
            text-decoration: none;
        }

    </style>
</head>
<body>
    <div class="ascii-header">  
░▒▓█▓▒░▒▓███████▓▒░░▒▓████████▓▒░▒▓██████▓▒░ ░▒▓██████▓▒░░▒▓█▓▒░      ░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓███████▓▒░        ░▒▓██████▓▒░░▒▓███████▓▒░░▒▓██████████████▓▒░░▒▓█▓▒░▒▓███████▓▒░  
░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓██████▓▒░ ░▒▓██████▓▒░░▒▓████████▓▒░▒▓██████▓▒░ ░▒▓██████▓▒░░▒▓███████▓▒░       ░▒▓█▓▒░░▒▓█▓▒░▒▓███████▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
                                                                                                                                                                                      
                                                                                                                                                                                                                                                                                                    
                          ADMIN PANEL v1.0</div>

    <div class="manager-container">
 <div class="panel system-status-panel"> <div class="panel-header">System Status & Controls</div>
            <div id="status-panel">
                <!-- Status items will be populated by JS -->
            </div>
            <p id="lastUpdated" style="font-size: var(--font-size-small); color: #777; text-align: right; margin-top: var(--padding-tight);">Last updated: N/A</p>
            
            <div class="system-controls-grid">
                <div class="llm-selector-container">
                    <label for="llmModelSelect">Active LLM Model:</label>
                    <select id="llmModelSelect">
                        <!-- Options will be populated by JS -->
                    </select>
                    <button id="setLlmModelButton" style="margin-left: var(--padding-tight); white-space: nowrap;">Set Model</button>
                </div>

                <div id="db-actions-container">
                    <h3>DB Actions</h3>
                    <button id="forceRefreshButton">Force Refresh All Feeds</button>
                    <button id="purgeDbButton" class="error">Purge News Items DB</button>
                    <p id="dbActionStatus"></p>
                </div>
            </div>
        </div>

        <div class="main-content-area">
            <div class="left-column">
                <div class="accordion-section">
                    <div class="accordion-header">Tag Statistics <span id="totalUniqueTagsHeader" style="font-weight: normal; color: var(--text-color); margin-left: 8px;">(Total: -)</span> <span class="arrow">▶</span></div>
                    <div class="accordion-content">
                        <div id="tagStatsContainer" style="display: flex; flex-direction: row; gap: var(--padding-loose);">
                            <div id="biasStatsContainer" style="flex: 1;">
                            <strong>Tags by Bias:</strong>
                            <div id="biasStats" style="padding-left: var(--padding-normal);">
                                <!-- Bias stats here -->
                            </div>
                        </div>
                            <div id="categoryStatsContainer" style="flex: 1;">
                            <strong>Tags by Category:</strong>
                            <div id="categoryStats" style="padding-left: var(--padding-normal);">
                                <!-- Category stats here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="accordion-section">
                    <div class="accordion-header">Source Management <span id="totalSourcesHeader" style="font-weight: normal; color: var(--text-color); margin-left: 8px;">(Total: -)</span> <span class="arrow">▶</span></div>
                    <div class="accordion-content">
                        <button id="showAddSourceModalButton" class="mt-1 mb-1">Add New Source</button>
                        <div style="margin-bottom: var(--padding-normal);">
                            <input type="text" id="sourceSearchInput" placeholder="Search sources by name or URL..." style="width: calc(100% - 120px); margin-right: var(--padding-tight);">
                            <button id="sourceSearchButton">Search</button>
                        </div>
                        <table id="sourcesTable">
                            <thead>
                                <tr>
                                    <th class="sortable-header" data-sort-key="name">Name <span class="sort-arrow"></span></th>
                                    <th class="sortable-header" data-sort-key="url">URL <span class="sort-arrow"></span></th>
                                    <th class="sortable-header" data-sort-key="category">Category <span class="sort-arrow"></span></th>
                                    <th class="sortable-header" data-sort-key="bias">Bias <span class="sort-arrow"></span></th>
                                    <th class="sortable-header" data-sort-key="minifluxFeedId">Miniflux ID <span class="sort-arrow"></span></th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="sourcesTableBody">
                                <!-- Source rows will be populated by JS -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="right-column">
                 <div class="panel">
                    <div class="panel-header">Log Stream</div>
                    <div id="logStream" style="height: 400px; background-color: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); overflow-y: scroll; padding: var(--padding-tight); font-size: var(--font-size-small); white-space: pre-wrap;">
                        Connecting to log stream...
                    </div>
                </div>
                <div class="panel">
                    <div class="panel-header">Miniflux Actions</div>
                     <button id="fixUnknownCategoriesButton" class="mt-1">Fix Unknown Categories in DB</button>
                     <p id="fixCategoriesStatus" class="mt-1"></p>
                </div>
            </div>
        </div>

    </div> <!-- end manager-container -->

    <!-- Add/Edit Source Modal -->
    <div id="sourceModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeModalButton">&times;</span>
            <h2 id="modalTitle">Add New Source</h2>
            <form id="sourceForm">
                <input type="hidden" id="sourceId" name="id">
                <label for="sourceName">Name:</label>
                <input type="text" id="sourceName" name="name" required>

                <label for="sourceUrl">URL:</label>
                <input type="url" id="sourceUrl" name="url" required>
                
                <label for="sourceAlternateUrl">Alternate URL (Optional):</label>
                <input type="url" id="sourceAlternateUrl" name="alternateUrl">

                <label for="sourceCategory">Category:</label>
                <select id="sourceCategory" name="category" required>
                    <!-- Options populated by JS -->
                </select>

                <label for="sourceBias">Bias:</label>
                <select id="sourceBias" name="bias" required>
                    <!-- Options populated by JS -->
                </select>
                
                <label for="sourceMinifluxFeedId">Miniflux Feed ID (Optional, auto-set if feed created):</label>
                <input type="number" id="sourceMinifluxFeedId" name="minifluxFeedId">

                <button type="submit" id="saveSourceButton" class="mt-1">Save Source</button>
            </form>
            <p id="modalError" class="error-message"></p>
        </div>
    </div>

    <div id="toast-notification">Toast message</div>

    <script>
        // <<< Define variables and functions in the outer scope >>>
        const API_BASE_URL = ''; // Assuming API is served from the same origin
        const statusPanel = document.getElementById('status-panel');
        const lastUpdatedDiv = document.getElementById('lastUpdated');
        const sourcesTableBody = document.getElementById('sourcesTableBody');
        const addSourceForm = document.getElementById('sourceForm');
        const categorySelect = document.getElementById('sourceCategory');
        const biasSelect = document.getElementById('sourceBias');
        const addSourceStatus = document.getElementById('modalError');
        const actionStatus = document.getElementById('dbActionStatus');
        const tagStatsContent = document.getElementById('tagStatsContainer');
        const totalUniqueTagsHeaderSpan = document.getElementById('totalUniqueTagsHeader');
        const totalSourcesHeaderSpan = document.getElementById('totalSourcesHeader');
        const sourceSearchInput = document.getElementById('sourceSearchInput');
        const llmModelSelect = document.getElementById('llmModelSelect');
        const modelUpdateStatus = document.getElementById('setLlmModelButton');
        const sourcesList = document.getElementById('sourcesTableBody');
        const sourceCountSpan = document.getElementById('totalArticlesStat');
        const addSourceButton = document.getElementById('saveSourceButton');
        const sourceActionStatus = document.getElementById('fixCategoriesStatus');
        const sourceCategorySelect = document.getElementById('sourceCategory');
        const sourceBiasSelect = document.getElementById('sourceBias');
        const purgeDbButton = document.getElementById('purgeDbButton');
        const forceRefreshButton = document.getElementById('forceRefreshButton');
        const fixCategoriesButton = document.getElementById('fixUnknownCategoriesButton');
        const logStreamDiv = document.getElementById('logStream'); // Added for log stream

        // Modal elements
        const sourceModal = document.getElementById('sourceModal');
        const showAddSourceModalButton = document.getElementById('showAddSourceModalButton');
        const closeModalButton = document.getElementById('closeModalButton');
        const modalTitle = document.getElementById('modalTitle');
        // const sourceForm = document.getElementById('sourceForm'); // Already defined as addSourceForm
        const modalError = document.getElementById('modalError');

        let sourcesData = [];
        let currentLlmModel = '';
        let allSources = [];
        let availableCategories = ['UNKNOWN'];
        let availableBiases = ['Unknown', 'Left', 'Liberal', 'Centrist', 'Conservative', 'Right'];
        let currentSortKey = null;
        let currentSortDirection = 'asc';
        let logWebSocket; // Added for log stream WebSocket object
        const MAX_LOG_LINES = 200; // Max number of log lines to keep

        // --- Function Definitions --- 

        // --- Function to add a message to the log stream ---
        function appendToLogStream(message, type = 'info') {
            if (!logStreamDiv) return;

            const logEntry = document.createElement('div');
            // Sanitize message to prevent HTML injection if logs might contain HTML-like strings
            const textNode = document.createTextNode(`[${new Date().toLocaleTimeString()}] ${message}`);
            logEntry.appendChild(textNode);
            
            if (type === 'error') {
                logEntry.style.color = 'var(--error-color)';
            } else if (type === 'system') {
                logEntry.style.color = 'var(--warning-color)'; 
            }

            while (logStreamDiv.childNodes.length >= MAX_LOG_LINES) {
                logStreamDiv.removeChild(logStreamDiv.firstChild);
            }

            logStreamDiv.appendChild(logEntry);
            logStreamDiv.scrollTop = logStreamDiv.scrollHeight; // Auto-scroll
        }

        // --- Function to Connect to Log Stream WebSocket ---
        function connectLogStream() {
            if (logWebSocket && (logWebSocket.readyState === WebSocket.OPEN || logWebSocket.readyState === WebSocket.CONNECTING)) {
                console.log("Log stream WebSocket already open or connecting.");
                return;
            }

            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            // Assuming admin page and backend API are on the same host and port for simplicity.
            // If backend is on a different port (e.g. 5001 for API) and admin is served differently (e.g. by backend on 5001 or by frontend dev server on 3000)
            // you might need to adjust wsHost. If admin.html is served by the backend on 5001, window.location.host should be correct.
            const wsHost = window.location.host; 
            // const wsHost = window.location.hostname + ':5001'; // Alternative if backend is on a fixed port like 5001
            const wsUrl = `${wsProtocol}//${wsHost}/ws/logs`;

            if (logStreamDiv.textContent.includes("Connecting to log stream...") || logStreamDiv.childNodes.length === 0) {
                 logStreamDiv.innerHTML = ''; // Clear initial static message
            }
            appendToLogStream('Attempting to connect to log stream at ' + wsUrl + '...', 'system');
            
            try {
                logWebSocket = new WebSocket(wsUrl);
            } catch (error) {
                console.error("Failed to create WebSocket:", error);
                appendToLogStream(`Failed to create WebSocket: ${error.message}. Retrying...`, 'error');
                setTimeout(connectLogStream, 5000); 
                return;
            }

            logWebSocket.onopen = function(event) {
                console.log("Log stream WebSocket connection established.");
                if (logStreamDiv.lastChild && logStreamDiv.lastChild.textContent.includes("Attempting to connect")) {
                    logStreamDiv.removeChild(logStreamDiv.lastChild); // Remove the specific "Attempting..." message
                }
                appendToLogStream("Connected to log stream.", 'system');
            };

            logWebSocket.onmessage = function(event) {
                appendToLogStream(event.data);
            };

            logWebSocket.onerror = function(event) {
                console.error("Log stream WebSocket error:", event);
                appendToLogStream("Log stream connection error.", 'error');
            };

            logWebSocket.onclose = function(event) {
                console.log("Log stream WebSocket connection closed. Code:", event.code, "Reason:", event.reason);
                appendToLogStream(`Disconnected from log stream. ${event.reason || ''}`, 'system');
                if (event.code !== 1000 && event.code !== 1001) { // Don't auto-retry on normal close
                    appendToLogStream("Attempting to reconnect in 5 seconds...", 'system');
                    setTimeout(connectLogStream, 5000);
                }
            };
        }

        // --- Status Update Function ---
        function updateStatus(statusData) { 
            console.log("🎨 updateStatus: Function called with data:", JSON.stringify(statusData));
            // ... (Keep entire function implementation here) ... 
             // Define order and friendly names
             const statusOrder = [
                { key: 'docker', name: 'Docker' },
                { key: 'mongodb', name: 'MongoDB' },
                { key: 'miniflux', name: 'Miniflux' },
                { key: 'ollama', name: 'Ollama' },
                { key: 'llmModel', name: 'LLM Active' }, // We'll update the dropdown selection separately
                { key: 'rssFeed', name: 'RSS Feed' },
                { key: 'llmQueue', name: 'LLM Queue' },
                { key: 'fallbackCount', name: 'Fallback Count' },
                { key: 'articlesInDB', name: 'Articles in DB' },
                { key: 'llmProcessed', name: 'LLM Processed' },
                { key: 'cpuUsage', name: 'CPU Usage' },
                { key: 'memory', name: 'Memory' }
            ];

             // Keep track of the current LLM model from status data
            const llmMessageParts = statusData.llmModel?.message?.split(':');
            if (llmMessageParts && llmMessageParts.length >= 2) {
                // Handles models like 'mistral' (no specific tag, often implies latest) 
                // or 'llama3:8b' (with tag) or 'mistral:latest'
                // We want to capture "name" or "name:tag"
                if (llmMessageParts[1].toLowerCase() === 'latest' || /^\d+[bB]$/.test(llmMessageParts[1].toLowerCase()) || /^\d+\.\d+[bB]$/.test(llmMessageParts[1].toLowerCase()) ) {
                    currentLlmModel = `${llmMessageParts[0]}:${llmMessageParts[1]}`;
                } else {
                    currentLlmModel = llmMessageParts[0]; // If the part after first colon isn't a typical tag
                }
            } else if (llmMessageParts && llmMessageParts.length === 1) {
                currentLlmModel = llmMessageParts[0]; // Only a name, no colons
            } else {
                currentLlmModel = '';
            }
            console.log("🎨 updateStatus: Extracted currentLlmModel as: ", currentLlmModel);

             // Clear previous status items except the LLM selector
             const llmSelector = statusPanel.querySelector('.llm-selector-container');
             statusPanel.innerHTML = ''; // Clear
             if (llmSelector) { // Re-append selector if it exists
                  statusPanel.appendChild(llmSelector);
             }

             // Helper to create status item
             const createStatusItem = (key, valueObj) => { // Expect valueObj like {status: 'good', message: '...:'} 
                const itemDiv = document.createElement('div');
                itemDiv.className = 'status-item';

                const lightSpan = document.createElement('span');
                lightSpan.className = 'status-light status-off'; // Default to off

                let displayValue = valueObj.message || `${key}: unknown`; // Use pre-formatted message
                let statusClass = 'status-off'; // Default class

                 // Determine status class based on valueObj.status
                 switch (valueObj.status) {
                    case 'good': statusClass = 'status-good'; break;
                    case 'warning': statusClass = 'status-warning'; break;
                    case 'bad': statusClass = 'status-bad'; break;
                    default: statusClass = 'status-off'; break;
                 }
                
                 lightSpan.classList.remove('status-off'); // Remove default
                 lightSpan.classList.add(statusClass); // Add calculated class

                 const textSpan = document.createElement('span');
                 textSpan.textContent = displayValue;

                 itemDiv.appendChild(lightSpan);
                 itemDiv.appendChild(textSpan);
                 return itemDiv;
             };

             // Add status items in order, skipping the model selector container
            statusOrder.forEach(item => {
                if (statusData.hasOwnProperty(item.key)) {
                    // Skip adding llmModel as a standard status item, handle via dropdown
                    if(item.key !== 'llmModel') {
                        const statusItemElement = createStatusItem(item.name, statusData[item.key]);
                        // Insert before the selector OR just append if selector is missing (shouldn't happen)
                        statusPanel.insertBefore(statusItemElement, llmSelector || null);
                    }
                }
            });
            
            // Add metrics separately if they exist
            if (statusData.metrics) {
                const metricsOrder = [
                    { key: 'articlesInDB', name: 'Articles in DB' },
                    { key: 'llmProcessed', name: 'LLM Processed' },
                    { key: 'fallbackCount', name: 'Fallback Count' },
                    { key: 'cpuUsage', name: 'CPU Usage' },
                    { key: 'memory', name: 'Memory' }
                ];
                
                 metricsOrder.forEach(item => {
                     let metricValue = statusData.metrics[item.key];
                     let message = `${item.name}: ${metricValue !== undefined ? metricValue : 'N/A'}`;
                     let metricStatus = 'good'; // Default for metrics
                     
                     // Special handling for processed count percentage
                     if (item.key === 'llmProcessed' && statusData.metrics.processedItemCount !== undefined && statusData.metrics.articlesInDB > 0) {
                         const processedCount = statusData.metrics.processedItemCount;
                         const totalCount = statusData.metrics.articlesInDB;
                         const percentage = ((processedCount / totalCount) * 100).toFixed(1);
                         message = `LLM Processed: ${processedCount} (${percentage}%)`;
                     }
                     // Special handling for fallback count status
                     if (item.key === 'fallbackCount' && metricValue > 0) {
                         metricStatus = 'warning';
                     }
                     
                     const metricItemElement = createStatusItem(item.name, { status: metricStatus, message: message });
                     statusPanel.insertBefore(metricItemElement, llmSelector || null);
                 });
            }

            // Update the LLM dropdown selection
            if (llmModelSelect.options.length > 1 && currentLlmModel) { // Only update if models are loaded & model known
                llmModelSelect.value = currentLlmModel;
                 if (llmModelSelect.selectedIndex === -1) {
                    console.warn(`Current model '${currentLlmModel}' not found in fetched model list.`);
                 }
            }

            lastUpdatedDiv.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
        }

        // --- Function to fetch status ---
        async function fetchStatus() { 
             console.log("📊 fetchStatus: Attempting to fetch status...");
             // ... (Keep implementation here) ...
             try {
                const response = await fetch('/status/api');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log("📊 fetchStatus: Received data:", JSON.stringify(data)); 
                updateStatus(data);
            } catch (error) {
                console.error('📊 fetchStatus: Error fetching status:', error);
                statusPanel.innerHTML = '<div class="status-item status-bad"><span>Error fetching status</span></div>'; // Show error in panel
            }
         }

        // --- Function to Populate LLM Models ---
        async function populateLlmModels() { 
             console.log("Fetching LLM models...");
             try {
                const response = await fetch('http://localhost:5001/status/ollama-models'); 
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const models = await response.json();

                llmModelSelect.innerHTML = ''; // Clear loading/existing options

                if (models && models.length > 0) {
                    models.forEach(model => {
                        const option = new Option(model.name, model.name);
                        llmModelSelect.add(option);
                    });
                    if(currentLlmModel) {
                       llmModelSelect.value = currentLlmModel;
                    }
                } else {
                    llmModelSelect.innerHTML = '<option value="">No models found</option>';
                }
                console.log("LLM models populated.");
            } catch (error) {
                console.error('Error fetching Ollama models:', error);
                llmModelSelect.innerHTML = '<option value="">Error loading models</option>';
            }
        }

        // --- Function to Handle LLM Model Selection ---
        async function handleModelChange() { 
             // ... (Keep implementation here) ... 
             const selectedModel = llmModelSelect.value;
            if (!selectedModel || selectedModel === currentLlmModel) return;

            console.log(`Attempting to set LLM model to: ${selectedModel}`);
            modelUpdateStatus.textContent = 'Updating...';
            llmModelSelect.disabled = true;

            try {
                const response = await fetch('http://localhost:5001/status/api/set-llm-model', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ model: selectedModel }),
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.message || `HTTP error! status: ${response.status}`);

                modelUpdateStatus.textContent = 'Model set!';
                currentLlmModel = selectedModel;
                fetchStatus(); // Refresh status
            } catch (error) {
                console.error('Error setting LLM model:', error);
                modelUpdateStatus.textContent = `Error: ${error.message}`;
                llmModelSelect.value = currentLlmModel;
            } finally {
                llmModelSelect.disabled = false;
                setTimeout(() => { modelUpdateStatus.textContent = ''; }, 3000);
            }
        }

        // --- Function to Fetch Config (Bias/Categories) ---
        async function fetchConfig() { 
             // ... (Keep implementation here) ... 
             try {
                const response = await fetch('http://localhost:5001/api/sources/config');
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const config = await response.json();
                availableCategories = config.sourceCategories || availableCategories;
                availableBiases = config.biasCategories || availableBiases;
                populateSelect(sourceCategorySelect, availableCategories);
                populateSelect(sourceBiasSelect, availableBiases);
            } catch (error) {
                 console.error('Error fetching source config:', error);
                 populateSelect(sourceCategorySelect, availableCategories);
                 populateSelect(sourceBiasSelect, availableBiases);
            }
         }
         function populateSelect(selectElement, options) { 
              // ... (Keep implementation here) ...
              selectElement.innerHTML = '<option value="" disabled selected>Select...</option>'; 
            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option;
                selectElement.appendChild(opt);
            });
          }

        // --- Functions for Source Management ---
        async function loadSources() { 
             // ... (Keep implementation here) ...
             sourcesList.innerHTML = '<tr><td colspan="7">Loading sources...</td></tr>';
            console.log("🔄 Loading sources...");
            try {
                const timestamp = Date.now();
                const response = await fetch(`http://localhost:5001/api/sources?_t=${timestamp}`, {
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const fetchedSources = await response.json();
                allSources = fetchedSources;
                console.log('✅ Sources loaded:', allSources.length, 'items');
                if (currentSortKey) {
                    console.log(`🔄 Re-applying sort by ${currentSortKey} (${currentSortDirection}) after loading`);
                    const tempDirection = currentSortDirection;
                    currentSortDirection = (tempDirection === 'asc') ? 'desc' : 'asc'; 
                    sortSources(currentSortKey);
                } else {
                    renderSourcesTable();
                }
            } catch (error) {
                console.error('❌ Error fetching sources:', error);
                sourcesList.innerHTML = `<tr><td colspan="7">Error loading sources: ${error.message}</td></tr>`;
                if (totalSourcesHeaderSpan) {
                    totalSourcesHeaderSpan.textContent = `(Total: Error)`;
                }
            }
         }
        function renderSourcesTable(sourcesToRender = allSources) { 
             // ... (Keep implementation here) ...
             console.log("🔄 Rendering sources table with", sourcesToRender.length, "sources");
            sourcesList.innerHTML = '';
            // Update header count: if sourcesToRender is the same as allSources, show allSources.length.
            // Otherwise, it's a filtered view, so show sourcesToRender.length.
            if (totalSourcesHeaderSpan) {
                if (sourcesToRender === allSources) {
                    totalSourcesHeaderSpan.textContent = `(Total: ${allSources.length})`;
                } else {
                    totalSourcesHeaderSpan.textContent = `(Filtered: ${sourcesToRender.length} / Total: ${allSources.length})`;
                }
            }
            if (sourcesToRender.length === 0) {
                sourcesList.innerHTML = '<tr><td colspan="6">No sources match search or none exist.</td></tr>'; // Adjusted colspan
                return;
            }
            sourcesToRender.forEach((source, index) => {
                const row = sourcesList.insertRow();
                row.insertCell().textContent = source.name || ''; // Name

                const urlCell = row.insertCell(); // URL
                if (source.url) {
                    const link = document.createElement('a');
                    link.href = source.url;
                    link.textContent = source.url;
                    link.target = '_blank'; // Open in new tab
                    link.style.color = 'var(--primary-accent-color)';
                    urlCell.appendChild(link);
                } else {
                    urlCell.textContent = '';
                }

                const categoryCell = row.insertCell(); // Category
                const categorySelect = document.createElement('select');
                categorySelect.dataset.field = 'category';
                categorySelect.dataset.sourceId = source.id;
                const sourceCategory = (source.category || '').trim();
                categorySelect.dataset.originalValue = sourceCategory;
                categorySelect.innerHTML = '';
                availableCategories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    option.selected = (sourceCategory === category);
                    categorySelect.appendChild(option);
                });
                categorySelect.disabled = !source.id;
                categoryCell.appendChild(categorySelect);

                const biasCell = row.insertCell(); // Bias
                const biasSelect = document.createElement('select');
                biasSelect.dataset.field = 'bias';
                biasSelect.dataset.sourceId = source.id;
                const sourceBias = (source.bias || '').trim();
                biasSelect.dataset.originalValue = sourceBias;
                biasSelect.innerHTML = '';
                availableBiases.forEach(bias => {
                    const option = document.createElement('option');
                    option.value = bias;
                    option.textContent = bias;
                    option.selected = (sourceBias === bias);
                    biasSelect.appendChild(option);
                });
                biasSelect.disabled = !source.id;
                biasCell.appendChild(biasSelect);

                const minifluxIdCell = row.insertCell(); // Miniflux ID
                minifluxIdCell.textContent = source.minifluxFeedId || 'Not Synced'; // Use camelCase

                const actionsCell = row.insertCell(); // Actions
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.classList.add('delete-button');
                if (source.id) {
                    deleteButton.addEventListener('click', () => deleteSource(source.id, source.name));
                } else {
                    deleteButton.disabled = true;
                    deleteButton.title = 'Cannot delete unsynced source';
                }
                actionsCell.appendChild(deleteButton);
            });
         }
        function filterSources() { 
            // ... (Keep implementation here) ...
             console.log("🔍 Filtering sources with search term:", sourceSearchInput.value);
            const searchTerm = sourceSearchInput.value.toLowerCase();
            const filteredSources = allSources.filter(source => (
                (source.name || '').toLowerCase().includes(searchTerm) ||
                (source.url || '').toLowerCase().includes(searchTerm) ||
                (source.category || '').toLowerCase().includes(searchTerm) ||
                (source.bias || '').toLowerCase().includes(searchTerm)
            ));
            console.log(`   Found ${filteredSources.length} sources matching search term`);
            renderSourcesTable(filteredSources);
         }
        function sortSources(key) { 
             // ... (Keep implementation here) ... 
             console.log(`🔄 Sorting sources by ${key}`);
            const direction = (key === currentSortKey && currentSortDirection === 'asc') ? 'desc' : 'asc';
            allSources.sort((a, b) => {
                let valA = a[key] || '';
                let valB = b[key] || '';
                if (key === 'minifluxFeedId') { // Corrected to camelCase
                    valA = parseInt(valA, 10) || 0;
                    valB = parseInt(valB, 10) || 0;
                    return direction === 'asc' ? valA - valB : valB - valA;
                }
                valA = String(valA).toLowerCase();
                valB = String(valB).toLowerCase();
                if (valA < valB) return direction === 'asc' ? -1 : 1;
                if (valA > valB) return direction === 'asc' ? 1 : -1;
                return 0;
            });
            currentSortKey = key;
            currentSortDirection = direction;
            document.querySelectorAll('#sourcesTable th.sortable-header .sort-arrow').forEach(arrowSpan => {
                arrowSpan.classList.remove('asc', 'desc');
                if (arrowSpan.parentElement.dataset.sortKey === key) {
                    arrowSpan.classList.add(direction);
                }
            });
            renderSourcesTable();
         }
         async function updateSourceField(sourceId, field, value) { 
             // ... (Keep implementation here) ... 
              console.log(`⭐ updateSourceField: Received sourceId: ${sourceId}, field: ${field}, value: ${value}`);
            sourceActionStatus.textContent = `Updating ${field} for source ${sourceId}...`;
            sourceActionStatus.className = '';
            try {
                const serverField = field === 'category' ? 'category' : field === 'bias' ? 'bias' : field;
                const response = await fetch(`/api/sources/${sourceId}?_t=${Date.now()}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    },
                    body: JSON.stringify({ [serverField]: value })
                });
                if (!response.ok) {
                    let errorMessage = `HTTP error! Status: ${response.status}`;
                    try {
                        const errorResult = await response.json();
                        errorMessage = errorResult.message || errorResult.error || errorMessage;
                    } catch (parseError) { console.warn("Could not parse error response as JSON."); }
                    throw new Error(errorMessage);
                }
                const result = await response.json();
                console.log(`✅ SERVER RESPONSE: Updated source ${sourceId}, set ${serverField}="${result[serverField]}"`);
                sourceActionStatus.textContent = `Source ${result.id} ${field} updated to ${result[serverField]}.`;
                sourceActionStatus.className = 'success';
                const sourceIndex = allSources.findIndex(s => s.id === sourceId);
                if (sourceIndex > -1) {
                    console.log(`✅ Updating allSources[${sourceIndex}].${field} from "${allSources[sourceIndex][field]}" to "${result[serverField]}"`);
                    allSources[sourceIndex][field] = result[serverField];
                } else { console.error(`❌ Could not find source with ID ${sourceId} in allSources`); }
                return true;
            } catch (error) {
                console.error(`❌ Error updating source ${sourceId} field ${field}:`, error);
                sourceActionStatus.textContent = `Error updating ${field}: ${error.message}`;
                sourceActionStatus.className = 'error';
                return false;
            }
          }
        async function handleAddSource(event) { 
            // ... (Keep implementation here) ... 
             event.preventDefault();
            sourceActionStatus.textContent = 'Adding source...';
            sourceActionStatus.className = '';
            addSourceButton.disabled = true;
            const formData = new FormData(addSourceForm);
            const sourceData = Object.fromEntries(formData.entries());
            try {
                const response = await fetch('/api/sources', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(sourceData)
                });
                 const result = await response.json();
                if (!response.ok) throw new Error(result.message || result.error || `HTTP error! Status: ${response.status}`);
                sourceActionStatus.textContent = `Source "${result.name}" added successfully. (Miniflux ID: ${result.miniflux_feed_id})`;
                sourceActionStatus.className = 'success';
                addSourceForm.reset();
                if(sourceModal) sourceModal.style.display = 'none'; // Close modal on success
                loadSources();
            } catch (error) {
                console.error('Error adding source:', error);
                sourceActionStatus.textContent = `Error adding source: ${error.message}`;
                 sourceActionStatus.className = 'error';
            } finally { addSourceButton.disabled = false; }
         }
        async function deleteSource(sourceId, sourceName) { 
            // ... (Keep implementation here) ... 
            if (!confirm(`Are you sure you want to delete the source "${sourceName}" (ID: ${sourceId})? This will remove it from the list and Miniflux.`)) return;
             sourceActionStatus.textContent = `Deleting source "${sourceName}"...`;
            sourceActionStatus.className = '';
            try {
                const response = await fetch(`/api/sources/${sourceId}`, { method: 'DELETE' });
                if (!response.ok) {
                     const result = await response.json().catch(() => ({}));
                    throw new Error(result.message || result.error || `HTTP error! Status: ${response.status}`);
                }
                sourceActionStatus.textContent = `Source "${sourceName}" deleted successfully.`;
                sourceActionStatus.className = 'success';
                loadSources();
            } catch (error) {
                console.error('Error deleting source:', error);
                 sourceActionStatus.textContent = `Error deleting source: ${error.message}`;
                sourceActionStatus.className = 'error';
            }
         }
         function handleFieldChange(selectElement) { 
            // ... (Keep implementation here) ... 
            console.log("🔵 handleFieldChange: Target Element:", selectElement);
            const sourceId = selectElement.dataset.sourceId;
            console.log(`🔵 handleFieldChange: Extracted sourceId: ${sourceId}`);
            const field = selectElement.dataset.field;
            const newValue = selectElement.value;
            const sourceIndex = allSources.findIndex(s => s.id === sourceId);
            if (sourceIndex === -1) {
                console.error(`❌ Cannot handle change: Source ID ${sourceId} not found`);
                return;
            }
            const currentValueInArray = allSources[sourceIndex][field];
            console.log(`🔄 Change detected on ${sourceId}/${field} to "${newValue}". Current value: "${currentValueInArray}"`);
            if (newValue === currentValueInArray) {
                console.log(`⏭️ Value hasn't changed, skipping update.`);
                selectElement.dataset.originalValue = newValue;
                return;
            }
            selectElement.disabled = true;
            updateSourceField(sourceId, field, newValue)
                .then(success => {
                    if (success) {
                        selectElement.dataset.originalValue = newValue;
                        console.log(`✅ Dataset originalValue updated for ${sourceId}/${field} to "${newValue}" AFTER success.`);
                    } else {
                        selectElement.value = currentValueInArray;
                        console.log(`⏪ Reverted dropdown for ${sourceId}/${field} to value: "${currentValueInArray}"`);
                    }
                })
                .finally(() => { selectElement.disabled = false; });
          }

        // --- Tag Statistics Logic ---
        async function loadTagStats() { 
            const biasStatsEl = document.getElementById('biasStats');
            const categoryStatsEl = document.getElementById('categoryStats');

            if (biasStatsEl) {
                biasStatsEl.innerHTML = '<p>Loading statistics...</p>';
            } else {
                console.error("Error: Could not find 'biasStats' element for loading message.");
            }
            if (categoryStatsEl) {
                categoryStatsEl.innerHTML = '<p>Loading statistics...</p>';
            } else {
                console.error("Error: Could not find 'categoryStats' element for loading message.");
            }

            try {
                const response = await fetch(`${API_BASE_URL}/status/api/admin/tag-stats`);
                     if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const stats = await response.json();
                displayTagStats(stats);
                 } catch (error) {
                console.error('Error loading tag statistics:', error);
                if (biasStatsEl) biasStatsEl.innerHTML = `<p class="error">Error loading statistics: ${error.message}</p>`;
                if (categoryStatsEl) categoryStatsEl.innerHTML = `<p class="error">Error loading statistics: ${error.message}</p>`;
            }
         }
        function displayTagStats(stats) { 
             // const tagStatsContent = document.getElementById('tagStatsContainer'); // Already global
             if (!tagStatsContent) { 
                 console.error("Error: tagStatsContainer element not found in displayTagStats"); 
                 return; 
             }

            const biasStatsEl = document.getElementById('biasStats');
            const categoryStatsEl = document.getElementById('categoryStats');

             if (!stats || typeof stats !== 'object') {
                 if (biasStatsEl) biasStatsEl.innerHTML = '<p class="error">Invalid stats format.</p>';
                 if (categoryStatsEl) categoryStatsEl.innerHTML = '<p class="error">Invalid stats format.</p>';
                 return;
             }
            
            // Update the total unique tags in the header
            if (totalUniqueTagsHeaderSpan) {
                totalUniqueTagsHeaderSpan.textContent = `(Total: ${stats.totalUniqueTags !== undefined ? stats.totalUniqueTags : '-'})`;
            }
            
            if (biasStatsEl) biasStatsEl.innerHTML = ''; // Clear previous
            if (categoryStatsEl) categoryStatsEl.innerHTML = ''; // Clear previous


            if (stats.byBias && Object.keys(stats.byBias).length > 0) {
                let biasHtml = '<ul>';
                 const biasOrder = ['Left', 'Liberal', 'Centrist', 'Unknown', 'Conservative', 'Right'];
                 biasOrder.forEach(bias => {
                     if (stats.byBias[bias] !== undefined) { biasHtml += `<li>${bias}: ${stats.byBias[bias]}</li>`; }
                 });
                 Object.entries(stats.byBias).forEach(([bias, count]) => {
                     if (!biasOrder.includes(bias)) { biasHtml += `<li>${bias}: ${count}</li>`; }
                 });
                biasHtml += '</ul>';
                if (biasStatsEl) biasStatsEl.innerHTML = biasHtml;
            } else {
                 if (biasStatsEl) biasStatsEl.innerHTML = '<p>(N/A)</p>';
            }

            if (stats.byCategory && Object.keys(stats.byCategory).length > 0) {
                let categoryHtml = '<ul>';
                Object.entries(stats.byCategory)
                    .sort(([, countA], [, countB]) => countB - countA)
                    .forEach(([category, count]) => { categoryHtml += `<li>${category}: ${count}</li>`; });
                categoryHtml += '</ul>';
                if (categoryStatsEl) categoryStatsEl.innerHTML = categoryHtml;
            } else {
                if (categoryStatsEl) categoryStatsEl.innerHTML = '<p>(N/A)</p>';
            }
         }

        // --- Functions for Database Actions ---
        async function handleDbAction(action) { 
             // ... (Keep implementation here) ...
             const buttonIdMap = { 'purge-db': 'purgeDbButton', 'force-refresh': 'forceRefreshButton', 'fix-categories': 'fixCategoriesButton' };
            const endpointMap = { 'purge-db': '/status/api/admin/purge-db', 'force-refresh': '/status/api/admin/force-refresh', 'fix-categories': '/api/sources/fix-unknown-categories' };
            const buttonId = buttonIdMap[action];
            const endpoint = endpointMap[action];
            const button = document.getElementById(buttonId);
            if (!button || !endpoint) { console.error('Invalid action:', action); return; }
            const originalText = button.textContent;
            button.disabled = true; button.textContent = 'Working...';
            purgeDbButton.disabled = true; forceRefreshButton.disabled = true; fixCategoriesButton.disabled = true;
            actionStatus.textContent = `Starting ${action}...`; actionStatus.className = '';
            try {
                const response = await fetch(endpoint, { method: 'POST' });
                const result = await response.json();
                if (!response.ok) throw new Error(result.message || `Action failed with status ${response.status}`);
                actionStatus.textContent = result.message || `${action} completed.`;
                actionStatus.className = 'success';
                fetchStatus();
                 if (action === 'fix-categories' || action === 'purge-db') { 
                     loadSources();
                     loadTagStats(); 
                 }
            } catch (error) {
                console.error(`Error during ${action}:`, error);
                actionStatus.textContent = `Error during ${action}: ${error.message}`; actionStatus.className = 'error';
            } finally {
                button.disabled = false; button.textContent = originalText;
                purgeDbButton.disabled = false; forceRefreshButton.disabled = false; fixCategoriesButton.disabled = false;
                setTimeout(() => { actionStatus.textContent = ''; }, 5000);
            }
          }

         // --- Accordion Logic --- 
         function setupAccordions() {
             document.querySelectorAll('.accordion-header').forEach(button => {
                const content = button.nextElementSibling;
                const sectionTitle = button.textContent || "";

                // Default states: Tag Stats closed, Source Management open
                if (sectionTitle.includes("Tag Statistics")) {
                    // Start closed
                    button.classList.remove('active');
                    content.classList.remove('active');
                    content.style.maxHeight = '0px';
                    content.style.paddingTop = '0';
                    content.style.paddingBottom = '0';
                } else { // For Source Management and any others, start open
                    button.classList.add('active');
                    content.classList.add('active');
                    content.style.maxHeight = 'none'; 
                    content.style.paddingTop = "var(--padding-normal)";
                    content.style.paddingBottom = "var(--padding-normal)";
                }

                // Add click listener for subsequent interactions
                 button.addEventListener('click', () => {
                     button.classList.toggle('active');
                     content.classList.toggle('active');
                     if (content.classList.contains('active')) {
                         content.style.maxHeight = 'none'; 
                         const scrollHeight = content.scrollHeight;
                         content.style.maxHeight = '0'; 
                         setTimeout(() => { 
                             content.style.maxHeight = scrollHeight + "px"; 
                             content.style.paddingTop = "var(--padding-normal)";
                             content.style.paddingBottom = "var(--padding-normal)";
                         }, 10);
                     } else {
                         content.style.maxHeight = '0px';
                         content.style.paddingTop = '0';
                         content.style.paddingBottom = '0';
                     }
                 });
             });
          }
          
         // --- Debug Tools --- 
         function setupDebugTools() {
             document.getElementById('debugUpdateBtn')?.addEventListener('click', async () => { /* ... */ });
             document.getElementById('debugGetSourceBtn')?.addEventListener('click', async () => { /* ... */ });
             document.getElementById('debugReloadBtn')?.addEventListener('click', async () => { /* ... */ });
             // Keep implementation for debug buttons here
              document.getElementById('debugUpdateBtn')?.addEventListener('click', async () => {
                  const debugOutput = document.getElementById('debugOutput');
                  const sourceId = document.getElementById('debugSourceId').value.trim();
                  const field = document.getElementById('debugField').value;
                  const value = document.getElementById('debugValue').value.trim();
                  if (!sourceId || !value) { debugOutput.innerHTML = '<p style="color: var(--error-color);">⚠️ Enter Source ID and value</p>'; return; }
                  debugOutput.innerHTML = `<p>Sending update for source ${sourceId}...</p>`;
                  try {
                      const updateResponse = await fetch(`/api/sources/${sourceId}?_t=${Date.now()}`, { method: 'PUT', headers: { 'Content-Type': 'application/json', 'Cache-Control': 'no-cache' }, body: JSON.stringify({ [field]: value }) });
                      const updateData = await updateResponse.json();
                      if (!updateResponse.ok) throw new Error(updateData.message || `Status: ${updateResponse.status}`);
                      debugOutput.innerHTML += `<p style="color: var(--accent-color);">✅ Server response: ${JSON.stringify(updateData)}</p>`;
                      const verifyResponse = await fetch(`/api/sources/${sourceId}?_t=${Date.now()}`, { headers: { 'Cache-Control': 'no-cache' }});
                      if (!verifyResponse.ok) throw new Error(`Failed to verify: ${verifyResponse.status}`);
                      const verifyData = await verifyResponse.json();
                      debugOutput.innerHTML += `<p>🔍 Verification: ${JSON.stringify(verifyData)}</p>`;
                      debugOutput.innerHTML += `<p style="color: ${verifyData[field] === value ? 'var(--accent-color)' : 'var(--error-color)'}">
                          Result: ${verifyData[field] === value ? 'SUCCESS' : 'FAILED'}
                      </p>`;
                  } catch (error) { debugOutput.innerHTML += `<p style="color: var(--error-color);">❌ Error: ${error.message}</p>`; }
              });
              document.getElementById('debugGetSourceBtn')?.addEventListener('click', async () => {
                  const debugOutput = document.getElementById('debugOutput');
                  const sourceId = document.getElementById('debugSourceId').value.trim();
                  if (!sourceId) { debugOutput.innerHTML = '<p style="color: var(--error-color);">⚠️ Enter Source ID</p>'; return; }
                  debugOutput.innerHTML = `<p>Fetching source ${sourceId}...</p>`;
                  try {
                      const response = await fetch(`/api/sources/${sourceId}?_t=${Date.now()}`, { headers: { 'Cache-Control': 'no-cache' }});
                      if (!response.ok) throw new Error(`Failed to get: ${response.status}`);
                      const data = await response.json();
                      debugOutput.innerHTML += `<p>📄 Data: ${JSON.stringify(data)}</p>`;
                  } catch (error) { debugOutput.innerHTML += `<p style="color: var(--error-color);">❌ Error: ${error.message}</p>`; }
              });
               document.getElementById('debugReloadBtn')?.addEventListener('click', async () => {
                  const debugOutput = document.getElementById('debugOutput');
                  debugOutput.innerHTML = '<p>Forcing reload...</p>';
                  try {
                      await loadSources();
                      debugOutput.innerHTML += '<p style="color: var(--accent-color);">✅ Sources reloaded</p>';
                      debugOutput.innerHTML += `<p>📊 Count: ${allSources.length}</p>`;
                      if (allSources.length > 0) {
                          debugOutput.innerHTML += '<p>Sample:</p>';
                          allSources.slice(0, 3).forEach(s => { debugOutput.innerHTML += `<p>${s.id}: ${s.name}</p>`; });
                      }
                  } catch (error) { debugOutput.innerHTML += `<p style="color: var(--error-color);">❌ Error: ${error.message}</p>`; }
              });
         }

        // --- DOMContentLoaded Listener (Initial Calls & Event Bindings) ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("🚀 DOM fully loaded. Initializing admin page...");

            // Setup Accordions - will now open them by default
            setupAccordions();

            // Setup Debug Tools
            // setupDebugTools(); // Assuming this might be optional or added later

            // Initial Data Fetches
            fetchConfig()
                .then(() => loadSources()) 
                .catch(error => console.error("Error in initial config/source fetch:", error));

            fetchStatus(); // Fetch initial status
            populateLlmModels(); // Fetch LLM models
            loadTagStats(); // Fetch initial tag stats

            connectLogStream(); // Initialize log stream connection

            // Setup Periodic Refresh
            setInterval(fetchStatus, 10000); // Refresh status every 10s
            setInterval(loadTagStats, 30000); // Refresh tags every 30s

            // Setup Event Listeners
            addSourceForm?.addEventListener('submit', handleAddSource);
            sourceSearchInput?.addEventListener('input', filterSources);
            llmModelSelect?.addEventListener('change', handleModelChange);
            sourcesList?.addEventListener('change', (event) => { // Delegated listener
                if (event.target.tagName === 'SELECT' && event.target.dataset.sourceId && event.target.dataset.field) {
                    handleFieldChange(event.target);
                }
            });
             document.querySelectorAll('#sourcesTable th.sortable-header').forEach(headerCell => {
                 headerCell.addEventListener('click', () => sortSources(headerCell.dataset.sortKey));
             });
             purgeDbButton?.addEventListener('click', () => { if (confirm('Are you SURE? This will delete ALL news items!')) { handleDbAction('purge-db'); } });
             forceRefreshButton?.addEventListener('click', () => handleDbAction('force-refresh'));
             fixCategoriesButton?.addEventListener('click', () => { if (confirm('Fix categories?')) { handleDbAction('fix-categories'); } });

            // Modal Event Listeners
            showAddSourceModalButton?.addEventListener('click', () => {
                if (sourceModal) {
                    sourceModal.style.display = 'block';
                    if (modalTitle) modalTitle.textContent = 'Add New Source';
                    addSourceForm.reset(); // Reset form fields
                    if(document.getElementById('sourceId')) document.getElementById('sourceId').value = ''; // Clear hidden ID
                    if (modalError) modalError.textContent = ''; // Clear any previous error messages
                }
            });

            closeModalButton?.addEventListener('click', () => {
                if (sourceModal) {
                    sourceModal.style.display = 'none';
                }
            });

            window.addEventListener('click', (event) => {
                if (event.target === sourceModal) {
                    sourceModal.style.display = 'none';
                }
            });

        });

    </script>
</body>
</html> 