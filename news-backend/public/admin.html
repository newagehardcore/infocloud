<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InfoCloud Backend Manager</title>
    <style>
        :root {
            --bg-color: #0D0D0D; /* Very dark grey / off-black */
            --text-color: #C0C0C0; /* Light grey */
            --primary-accent-color: #00FF00; /* Bright Green */
            --secondary-accent-color: #00A000; /* Darker Green */
            --border-color: #2A2A2A; /* Dark grey for borders */
            --error-color: #FF3333; /* Bright Red */
            --warning-color: #FFFF00; /* Bright Yellow */
            --input-bg-color: #1A1A1A;
            --button-bg-color: #222222;
            --button-hover-bg-color: #333333;
            --header-bg-color: #1A1A1A;
            --content-bg-color: #101010;

            --font-family-monospace: "Menlo", "Monaco", "Consolas", "Liberation Mono", "Courier New", monospace;
            --font-family-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;

            --padding-tight: 4px;
            --padding-normal: 8px;
            --padding-loose: 12px;

            --border-radius-sharp: 0px;
            --border-width: 1px;

            --font-size-small: 12px;
            --font-size-normal: 14px;
            --font-size-large: 16px;
            --font-size-xl: 20px;
            --line-height: 1.4;
        }

        body {
            font-family: var(--font-family-monospace);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: var(--padding-loose);
            font-size: var(--font-size-normal);
            line-height: var(--line-height);
        }

        .ascii-header {
            font-family: var(--font-family-monospace);
            color: var(--primary-accent-color);
            white-space: pre;
            text-align: center;
            font-size: 10px; /* Smaller for ASCII art */
            line-height: 1.1;
            padding: var(--padding-normal) 0;
            background-color: var(--bg-color); /* Match body or slightly different */
            border-bottom: var(--border-width) solid var(--border-color);
            margin-bottom: var(--padding-loose);
        }

        .manager-container {
            display: flex;
            flex-direction: column;
            gap: var(--padding-loose);
        }
        
        .main-content-area {
            display: flex;
            flex-direction: row; /* For side-by-side layout */
            gap: var(--padding-loose);
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .left-column {
            flex: 2; /* Takes 2/3 of the space */
            display: flex;
            flex-direction: column;
            gap: var(--padding-loose);
            min-width: 300px; /* Minimum width before wrapping */
        }

        .right-column {
            flex: 1; /* Takes 1/3 of the space */
            display: flex;
            flex-direction: column;
            gap: var(--padding-loose);
            min-width: 250px; /* Minimum width before wrapping */
        }

        .panel {
            background-color: var(--content-bg-color);
            border: var(--border-width) solid var(--border-color);
            border-radius: var(--border-radius-sharp);
            padding: var(--padding-normal);
        }

        .panel-header {
            font-size: var(--font-size-large);
            color: var(--primary-accent-color);
            margin: 0 0 var(--padding-normal) 0;
            padding-bottom: var(--padding-tight);
            border-bottom: var(--border-width) solid var(--secondary-accent-color);
            font-weight: normal;
        }

        /* Status Panel Styles */
        #status-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--padding-normal);
        }

        .status-item {
            background-color: var(--input-bg-color);
            padding: var(--padding-tight) var(--padding-normal);
            border: var(--border-width) solid var(--border-color);
            border-radius: var(--border-radius-sharp);
            display: flex;
            align-items: center;
            gap: var(--padding-tight);
            font-size: var(--font-size-small);
        }

        .status-light {
            width: 10px;
            height: 10px;
            border-radius: var(--border-radius-sharp); /* Square lights */
            margin-right: var(--padding-tight);
            background-color: #444; /* Default off */
            flex-shrink: 0;
            border: 1px solid #555; /* Subtle border for the light */
        }

        .status-light.status-good { background-color: var(--primary-accent-color); }
        .status-light.status-warning { background-color: var(--warning-color); }
        .status-light.status-bad { background-color: var(--error-color); }
        .status-light.status-off { background-color: #333; }


        /* LLM Selector & DB Actions */
        .system-controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--padding-normal);
            margin-bottom: var(--padding-normal);
        }

        .llm-selector-container, #db-actions-container {
            background-color: var(--input-bg-color);
            padding: var(--padding-tight) var(--padding-normal); /* Reduced padding */
            border: var(--border-width) solid var(--border-color);
            border-radius: var(--border-radius-sharp);
            display: flex; /* Added for horizontal layout */
            align-items: center; /* Vertically align items */
            gap: var(--padding-tight); /* Space between items */
        }
        .llm-selector-container label {
            margin-bottom: 0; /* Remove bottom margin from label */
            margin-right: var(--padding-tight);
            white-space: nowrap;
        }
        .llm-selector-container select {
            flex-grow: 1; /* Allow select to take available space */
            margin-bottom: 0; /* Remove bottom margin if any from global styles */
        }
         #db-actions-container h3 {
            color: var(--primary-accent-color);
            font-size: var(--font-size-normal);
            margin: 0 var(--padding-normal) 0 0; /* Adjust margin */
            padding-bottom: 0; /* Remove padding */
            border-bottom: none; /* Remove border */
            white-space: nowrap;
         }
         #db-actions-container button {
            margin-left: var(--padding-tight); /* Add some space between buttons */
         }
         #dbActionStatus {
            width: 100%; /* Make status take full width below */
            text-align: left; /* Align to left below buttons */
            margin-top: var(--padding-tight);
            font-size: var(--font-size-small);
            flex-basis: 100%; /* Ensure it wraps to the next line */
         }


        /* Accordion Styles */
        .accordion-section {
            background-color: var(--content-bg-color);
            border: var(--border-width) solid var(--border-color);
            border-radius: var(--border-radius-sharp);
            margin-bottom: var(--padding-normal); /* Keep some separation */
        }

        .accordion-header {
            background-color: var(--header-bg-color);
            color: var(--primary-accent-color);
            cursor: pointer;
            padding: var(--padding-normal);
            border: none; /* Remove default border */
            border-bottom: var(--border-width) solid var(--border-color); /* Border for separation */
            text-align: left;
            outline: none;
            font-size: var(--font-size-large);
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: normal;
        }
        .accordion-header:hover {
            background-color: var(--secondary-accent-color);
            color: var(--bg-color);
        }
        .accordion-header .arrow {
           font-size: var(--font-size-normal);
           margin-left: var(--padding-tight);
           transition: transform 0.2s ease-in-out;
        }
        .accordion-header.active .arrow { transform: rotate(90deg); }
        .accordion-content {
            padding: var(--padding-normal);
            background-color: var(--content-bg-color); /* Slightly different or same as panel */
            max-height: 0;
            overflow-y: auto; /* Changed to auto for scroll if content is too long */
            overflow-x: hidden;
            transition: max-height 0.2s ease-out;
            border-top: none; /* No top border as header has bottom */
        }
        .accordion-content.active {
            /* max-height will be set by JS */
        }


        /* DB Stats Visualization */
        #dbStats .stat-item, #tagStats .stat-item, #biasStats .stat-item, #categoryStats .stat-item {
            margin-bottom: var(--padding-tight);
            font-size: var(--font-size-small);
        }
        #dbStats .stat-item strong, #tagStats .stat-item strong, #biasStats .stat-item strong, #categoryStats .stat-item strong {
            color: var(--primary-accent-color);
            min-width: 150px; /* Align keys */
            display: inline-block;
        }
        /* Basic bar for LLM Fallback */
        .stat-bar-container {
            background-color: var(--border-color);
            height: 10px;
            width: 100px;
            display: inline-block;
            border-radius: var(--border-radius-sharp);
            overflow: hidden;
            margin-left: var(--padding-tight);
        }
        .stat-bar {
            background-color: var(--primary-accent-color);
            height: 100%;
            width: 0%; /* Set by JS or defaults */
            border-radius: var(--border-radius-sharp);
        }
         .stat-bar.warning { background-color: var(--warning-color); }
         .stat-bar.error { background-color: var(--error-color); }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: var(--font-size-small);
        }
        th, td {
            border: var(--border-width) solid var(--border-color);
            padding: var(--padding-tight);
            text-align: left;
            vertical-align: top; /* Better for multi-line content in cells */
        }
        /* Add this for tighter select padding */
        #sourcesTable select {
            padding-top: 1px;
            padding-bottom: 1px;
            font-size: calc(var(--font-size-small) - 1px); /* Slightly smaller font for selects */
        }
        th {
            background-color: var(--header-bg-color);
            color: var(--primary-accent-color);
            font-weight: normal;
        }
        th.sortable-header {
            cursor: pointer;
        }
        th.sortable-header:hover {
            background-color: var(--secondary-accent-color);
            color: var(--bg-color);
        }
        th .sort-arrow {
            float: right;
            font-size: 0.8em;
            margin-left: 5px;
        }
        th .sort-arrow.asc::after { content: ' â–²'; }
        th .sort-arrow.desc::after { content: ' â–¼'; }

        tbody tr:nth-child(odd) {
            background-color: var(--input-bg-color); /* Subtle striping */
        }
        tbody tr:hover {
            background-color: var(--secondary-accent-color);
            color: var(--bg-color);
        }

        /* Form Elements */
        input[type="text"], input[type="url"], input[type="number"], select, textarea {
            background-color: var(--input-bg-color);
            color: var(--text-color);
            border: var(--border-width) solid var(--border-color);
            border-radius: var(--border-radius-sharp);
            padding: var(--padding-tight);
            font-family: var(--font-family-monospace);
            font-size: var(--font-size-normal);
            width: calc(100% - 10px); /* Adjust for padding */
            margin-bottom: var(--padding-tight);
        }
        input[type="text"]:focus, input[type="url"]:focus, input[type="number"]:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-accent-color);
            box-shadow: 0 0 3px var(--primary-accent-color);
        }
        button, input[type="submit"] {
            background-color: var(--button-bg-color);
            color: var(--primary-accent-color);
            border: var(--border-width) solid var(--secondary-accent-color);
            border-radius: var(--border-radius-sharp);
            padding: var(--padding-tight) var(--padding-normal);
            cursor: pointer;
            font-family: var(--font-family-monospace);
            font-size: var(--font-size-normal);
            transition: background-color 0.2s, color 0.2s;
        }
        button:hover, input[type="submit"]:hover {
            background-color: var(--primary-accent-color);
            color: var(--bg-color);
        }
        button:disabled {
            background-color: #222;
            color: #555;
            border-color: #333;
            cursor: not-allowed;
        }
        label {
            display: block;
            margin-bottom: var(--padding-tight);
            font-size: var(--font-size-small);
        }
        
        /* Utility classes */
        .hidden { display: none; }
        .text-center { text-align: center; }
        .mt-1 { margin-top: var(--padding-normal); }
        .mb-1 { margin-bottom: var(--padding-normal); }
        .error-message { color: var(--error-color); font-size: var(--font-size-small); }
        .success-message { color: var(--primary-accent-color); font-size: var(--font-size-small); }
        
        /* Toast Notification */
        #toast-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--input-bg-color);
            color: var(--text-color);
            padding: var(--padding-normal) var(--padding-loose);
            border-radius: var(--border-radius-sharp);
            border: var(--border-width) solid var(--border-color);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            z-index: 1000;
            font-size: var(--font-size-normal);
            opacity: 0;
            transition: opacity 0.3s ease, bottom 0.3s ease;
            visibility: hidden;
        }
        #toast-notification.show {
            opacity: 1;
            bottom: 30px;
            visibility: visible;
        }
        #toast-notification.success { border-left: 5px solid var(--primary-accent-color); }
        #toast-notification.error { border-left: 5px solid var(--error-color); }
        #toast-notification.warning { border-left: 5px solid var(--warning-color); }

        /* Modal styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; 
            z-index: 1001; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
        }

        .modal-content {
            background-color: var(--content-bg-color);
            margin: 10% auto; /* 10% from the top and centered */
            padding: var(--padding-loose);
            border: var(--border-width) solid var(--primary-accent-color);
            border-radius: var(--border-radius-sharp);
            width: 80%; /* Could be more or less, depending on screen size */
            max-width: 600px; /* Maximum width */
            color: var(--text-color);
        }
        .modal-content h2 {
            color: var(--primary-accent-color);
            font-size: var(--font-size-large);
            margin-top:0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: var(--padding-normal);
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close-button:hover,
        .close-button:focus {
            color: var(--primary-accent-color);
            text-decoration: none;
        }

        .import-export-controls {
            display: flex;
            gap: var(--padding-normal);
            align-items: center;
            margin-bottom: var(--padding-normal);
        }
        .panel-subheader { /* Assuming this style exists and is appropriate */
            font-size: var(--font-size-normal);
            color: var(--primary-accent-color);
            margin: var(--padding-normal) 0 var(--padding-tight) 0;
            padding-bottom: var(--padding-tight);
            border-bottom: 1px solid var(--secondary-accent-color);
            font-weight: normal;
        }
        .panel-divider {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: var(--padding-normal) 0;
        }
        .status-message {
            padding: 8px;
            margin-top: 8px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .status-message.info { background-color: #e0e0ff; color: #333; border: 1px solid #c0c0dd; }
        .status-message.success { background-color: #e0ffe0; color: #006400; border: 1px solid #c0dcc0; }
        .status-message.warning { background-color: #ffffe0; color: #8B4513; border: 1px solid #ddddc0; }
        .status-message.error { background-color: #ffe0e0; color: #A52A2A; border: 1px solid #ddc0c0; }

    </style>
</head>
<body>
    <div class="ascii-header">  
â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘        â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘  
â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘     â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘     â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘ 
â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘     â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘     â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘ 
â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘     â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘ 
â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘     â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘     â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘ 
â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘     â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘     â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘ 
â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘       â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘ 
                                                                                                                                                                                      
                                                                                                                                                                                                                                                                                                    
                          ADMIN PANEL v1.0</div>

    <div class="manager-container">
 <div class="panel system-status-panel"> <div class="panel-header">System Status & Controls</div>
            <div id="status-panel">
                <!-- Status items will be populated by JS -->
            </div>
            <p id="lastUpdated" style="font-size: var(--font-size-small); color: #777; text-align: right; margin-top: var(--padding-tight);">Last updated: N/A</p>
            
            <div class="system-controls-grid">
                <div class="llm-selector-container">
                    <label for="llmModelSelect">Active LLM Model:</label>
                    <select id="llmModelSelect">
                        <!-- Options will be populated by JS -->
                    </select>
                    <button id="setLlmModelButton" style="margin-left: var(--padding-tight); white-space: nowrap;">Set Model</button>
                </div>

                <div id="db-actions-container">
                    <h3>DB Actions</h3>
                    <button id="forceRefreshButton">Force Refresh All Feeds</button>
                    <button id="purgeDbButton" class="error">Purge News Items DB</button>
                    <p id="dbActionStatus"></p>
                </div>
            </div>
        </div>

        <div class="main-content-area">
            <div class="left-column">
                <div class="accordion-section">
                    <div class="accordion-header">Tag Statistics <span id="totalUniqueTagsHeader" style="font-weight: normal; color: var(--text-color); margin-left: 8px;">(Total: -)</span> <span class="arrow">â–¶</span></div>
                    <div class="accordion-content">
                        <div id="tagStatsContainer" style="display: flex; flex-direction: row; gap: var(--padding-loose);">
                            <div id="biasStatsContainer" style="flex: 1;">
                            <strong>Tags by Bias:</strong>
                            <div id="biasStats" style="padding-left: var(--padding-normal);">
                                <!-- Bias stats here -->
                            </div>
                        </div>
                            <div id="categoryStatsContainer" style="flex: 1;">
                            <strong>Tags by Category:</strong>
                            <div id="categoryStats" style="padding-left: var(--padding-normal);">
                                <!-- Category stats here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="accordion-section" id="source-management-accordion">
                    <button class="accordion-header">Source Management <span class="arrow">â–¶</span></button>
                    <div class="accordion-content" id="sourceManagementContent">
                        <h3 class="panel-subheader">Add New Source</h3>
                        <form id="addSourceForm" class="source-form">
                            <input type="hidden" id="sourceId" name="id">
                            <label for="sourceName">Name:</label>
                            <input type="text" id="sourceName" name="name" required>

                            <label for="sourceUrl">URL:</label>
                            <input type="url" id="sourceUrl" name="url" required>
                            
                            <label for="sourceAlternateUrl">Alternate URL (Optional):</label>
                            <input type="url" id="sourceAlternateUrl" name="alternateUrl">

                            <label for="sourceCategory">Category:</label>
                            <select id="sourceCategory" name="category" required>
                                <!-- Options populated by JS -->
                            </select>

                            <label for="sourceBias">Bias:</label>
                            <select id="sourceBias" name="bias" required>
                                <!-- Options populated by JS -->
                            </select>
                            
                            <label for="sourceType">Type:</label>
                            <select id="sourceType" name="type" required>
                                <!-- Options populated by JS -->
                            </select>

                            <label for="sourceMinifluxFeedId">Miniflux Feed ID (Optional, auto-set if feed created):</label>
                            <input type="number" id="sourceMinifluxFeedId" name="minifluxFeedId">

                            <button type="submit" id="saveSourceButton" class="mt-1">Save Source</button>
                        </form>
                        <p id="modalError" class="error-message"></p>

                        <hr class="panel-divider">

                        <h3 class="panel-subheader">Import/Export Sources</h3>
                        <div class="import-export-controls">
                            <button id="exportSourcesBtn" class="action-button">Export All Sources</button>
                            <input type="file" id="importFile" accept=".json" style="display: none;">
                            <button id="importSourcesBtn" class="action-button">Import Sources from JSON</button>
                            <button id="purgeSourcesDbBtn" class="action-button error" style="margin-left: auto;">Purge All Sources DB</button> <!-- Added Purge Button -->
                        </div>
                        <div id="importExportStatus" class="status-message" style="margin-top: 8px;"></div>

                        <hr class="panel-divider">

                        <h3 class="panel-subheader" id="sourceListHeader">Source List (<span id="sourceCount">0</span>)</h3>
                        <div class="filter-controls">
                            <input type="text" id="sourceSearchInput" placeholder="Search sources by name or URL..." style="width: calc(100% - 120px); margin-right: var(--padding-tight);">
                            <button id="sourceSearchButton">Search</button>
                        </div>
                        <table id="sourcesTable" style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr>
                                    <th class="sortable-header" data-sort-key="name">Name</th>
                                    <th>URL</th>
                                    <th class="sortable-header" data-sort-key="category">Category</th>
                                    <th class="sortable-header" data-sort-key="bias">Bias</th>
                                    <th class="sortable-header" data-sort-key="type">Type</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="sourcesTableBody">
                                <!-- Source rows will be populated by JS -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="right-column">
                 <div class="panel">
                    <div class="panel-header">Log Stream</div>
                    <div id="logStream" style="height: 400px; background-color: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); overflow-y: scroll; padding: var(--padding-tight); font-size: var(--font-size-small); white-space: pre-wrap;">
                        Connecting to log stream...
                    </div>
                </div>
                <div class="panel">
                    <div class="panel-header">Miniflux Actions</div>
                     <button id="fixUnknownCategoriesButton" class="mt-1">Fix Unknown Categories in DB</button>
                     <p id="fixCategoriesStatus" class="mt-1"></p>
                </div>
            </div>
        </div>

    </div> <!-- end manager-container -->

    <!-- Add/Edit Source Modal -->
    <div id="sourceModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeModalButton">&times;</span>
            <h2 id="modalTitle">Add New Source</h2>
            <form id="sourceForm">
                <input type="hidden" id="sourceId" name="id">
                <label for="sourceName">Name:</label>
                <input type="text" id="sourceName" name="name" required>

                <label for="sourceUrl">URL:</label>
                <input type="url" id="sourceUrl" name="url" required>
                
                <label for="sourceAlternateUrl">Alternate URL (Optional):</label>
                <input type="url" id="sourceAlternateUrl" name="alternateUrl">

                <label for="sourceCategory">Category:</label>
                <select id="sourceCategory" name="category" required>
                    <!-- Options populated by JS -->
                </select>

                <label for="sourceBias">Bias:</label>
                <select id="sourceBias" name="bias" required>
                    <!-- Options populated by JS -->
                </select>
                
                <label for="sourceType">Type:</label>
                <select id="sourceType" name="type" required>
                    <!-- Options populated by JS -->
                </select>

                <label for="sourceMinifluxFeedId">Miniflux Feed ID (Optional, auto-set if feed created):</label>
                <input type="number" id="sourceMinifluxFeedId" name="minifluxFeedId">

                <button type="submit" id="saveSourceButton" class="mt-1">Save Source</button>
            </form>
            <p id="modalError" class="error-message"></p>
        </div>
    </div>

    <div id="toast-notification">Toast message</div>

    <script>
        // <<< Define variables and functions in the outer scope >>>
        const API_BASE_URL = window.location.origin; // This will get the correct origin in Docker
        const statusPanel = document.getElementById('status-panel');
        const lastUpdatedDiv = document.getElementById('lastUpdated');
        const sourcesList = document.getElementById('sourcesTableBody'); // Corrected back to table body ID
        const addSourceForm = document.getElementById('sourceForm'); // This is for the modal
        const categorySelect = document.getElementById('sourceCategory');
        const biasSelect = document.getElementById('sourceBias');
        const addSourceStatus = document.getElementById('modalError');
        const actionStatus = document.getElementById('dbActionStatus');
        const tagStatsContent = document.getElementById('tagStatsContainer');
        const totalUniqueTagsHeaderSpan = document.getElementById('totalUniqueTagsHeader');
        const sourceListHeader = document.getElementById('sourceListHeader'); // This contains the sourceCount span
        const sourceCountSpan = document.getElementById('sourceCount'); // The actual span for the number
        const sourceSearchInput = document.getElementById('sourceSearchInput');
        const llmModelSelect = document.getElementById('llmModelSelect');
        const modelUpdateStatus = document.getElementById('setLlmModelButton');
        const addSourceButton = document.getElementById('saveSourceButton');
        const sourceActionStatus = document.getElementById('fixCategoriesStatus');
        const sourceCategorySelect = document.getElementById('sourceCategory');
        const sourceBiasSelect = document.getElementById('sourceBias');
        const purgeDbButton = document.getElementById('purgeDbButton');
        const forceRefreshButton = document.getElementById('forceRefreshButton');
        const fixCategoriesButton = document.getElementById('fixUnknownCategoriesButton');
        const logStreamDiv = document.getElementById('logStream'); // Added for log stream

        // Modal elements
        const sourceModal = document.getElementById('sourceModal');
        const showAddSourceModalButton = document.getElementById('showAddSourceModalButton');
        const closeModalButton = document.getElementById('closeModalButton');
        const modalTitle = document.getElementById('modalTitle');
        // const sourceForm = document.getElementById('sourceForm'); // Already defined as addSourceForm
        const modalError = document.getElementById('modalError');

        let sourcesData = [];
        let currentLlmModel = '';
        let allSources = [];
        let availableCategories = ['UNKNOWN'];
        let availableBiases = ['Unknown', 'Left', 'Liberal', 'Centrist', 'Conservative', 'Right'];
        let currentSortKey = null;
        let currentSortDirection = 'asc';
        let logWebSocket; // Added for log stream WebSocket object
        const MAX_LOG_LINES = 200; // Max number of log lines to keep

        // Add this to the script section where global variables are defined (around line 579)
        let availableTypes = ['INDEPENDENT', 'CORPORATE', 'STATE', 'UNKNOWN'];

        // --- Function Definitions --- 

        // --- Function to add a message to the log stream ---
        function appendToLogStream(message, type = 'info') {
            if (!logStreamDiv) return;

            const logEntry = document.createElement('div');
            // Sanitize message to prevent HTML injection if logs might contain HTML-like strings
            const textNode = document.createTextNode(`[${new Date().toLocaleTimeString()}] ${message}`);
            logEntry.appendChild(textNode);
            
            if (type === 'error') {
                logEntry.style.color = 'var(--error-color)';
            } else if (type === 'system') {
                logEntry.style.color = 'var(--warning-color)'; 
            }

            while (logStreamDiv.childNodes.length >= MAX_LOG_LINES) {
                logStreamDiv.removeChild(logStreamDiv.firstChild);
            }

            logStreamDiv.appendChild(logEntry);
            logStreamDiv.scrollTop = logStreamDiv.scrollHeight; // Auto-scroll
        }

        // --- Function to Connect to Log Stream WebSocket ---
        function connectLogStream() {
            if (logWebSocket && (logWebSocket.readyState === WebSocket.OPEN || logWebSocket.readyState === WebSocket.CONNECTING)) {
                console.log("Log stream WebSocket already open or connecting.");
                return;
            }

            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            // Assuming admin page and backend API are on the same host and port for simplicity.
            // If backend is on a different port (e.g. 5001 for API) and admin is served differently (e.g. by backend on 5001 or by frontend dev server on 3000)
            // you might need to adjust wsHost. If admin.html is served by the backend on 5001, window.location.host should be correct.
            const wsHost = window.location.host; 
            // const wsHost = window.location.hostname + ':5001'; // Alternative if backend is on a fixed port like 5001
            const wsUrl = `${wsProtocol}//${wsHost}/ws/logs`;

            if (logStreamDiv.textContent.includes("Connecting to log stream...") || logStreamDiv.childNodes.length === 0) {
                 logStreamDiv.innerHTML = ''; // Clear initial static message
            }
            appendToLogStream('Attempting to connect to log stream at ' + wsUrl + '...', 'system');
            
            try {
                logWebSocket = new WebSocket(wsUrl);
            } catch (error) {
                console.error("Failed to create WebSocket:", error);
                appendToLogStream(`Failed to create WebSocket: ${error.message}. Retrying...`, 'error');
                setTimeout(connectLogStream, 5000); 
                return;
            }

            logWebSocket.onopen = function(event) {
                console.log("Log stream WebSocket connection established.");
                if (logStreamDiv.lastChild && logStreamDiv.lastChild.textContent.includes("Attempting to connect")) {
                    logStreamDiv.removeChild(logStreamDiv.lastChild); // Remove the specific "Attempting..." message
                }
                appendToLogStream("Connected to log stream.", 'system');
            };

            logWebSocket.onmessage = function(event) {
                appendToLogStream(event.data);
            };

            logWebSocket.onerror = function(event) {
                console.error("Log stream WebSocket error:", event);
                appendToLogStream("Log stream connection error.", 'error');
            };

            logWebSocket.onclose = function(event) {
                console.log("Log stream WebSocket connection closed. Code:", event.code, "Reason:", event.reason);
                appendToLogStream(`Disconnected from log stream. ${event.reason || ''}`, 'system');
                if (event.code !== 1000 && event.code !== 1001) { // Don't auto-retry on normal close
                    appendToLogStream("Attempting to reconnect in 5 seconds...", 'system');
                    setTimeout(connectLogStream, 5000);
                }
            };
        }

        // --- Status Update Function ---
        function updateStatus(statusData) { 
            console.log("ðŸŽ¨ updateStatus: Function called with data:", JSON.stringify(statusData));
            // ... (Keep entire function implementation here) ... 
             // Define order and friendly names
             const statusOrder = [
                { key: 'docker', name: 'Docker' },
                { key: 'mongodb', name: 'MongoDB' },
                { key: 'miniflux', name: 'Miniflux' },
                { key: 'ollama', name: 'Ollama' },
                { key: 'llmModel', name: 'LLM Active' }, // We'll update the dropdown selection separately
                { key: 'rssFeed', name: 'RSS Feed' },
                { key: 'llmQueue', name: 'LLM Queue' },
                { key: 'fallbackCount', name: 'Fallback Count' },
                { key: 'articlesInDB', name: 'Articles in DB' },
                { key: 'llmProcessed', name: 'LLM Processed' },
                { key: 'cpuUsage', name: 'CPU Usage' },
                { key: 'memory', name: 'Memory' }
            ];

             // Keep track of the current LLM model from status data
            const llmMessageParts = statusData.llmModel?.message?.split(':');
            if (llmMessageParts && llmMessageParts.length >= 2) {
                // Handles models like 'mistral' (no specific tag, often implies latest) 
                // or 'llama3:8b' (with tag) or 'mistral:latest'
                // We want to capture "name" or "name:tag"
                if (llmMessageParts[1].toLowerCase() === 'latest' || /^\d+[bB]$/.test(llmMessageParts[1].toLowerCase()) || /^\d+\.\d+[bB]$/.test(llmMessageParts[1].toLowerCase()) ) {
                    currentLlmModel = `${llmMessageParts[0]}:${llmMessageParts[1]}`;
                } else {
                    currentLlmModel = llmMessageParts[0]; // If the part after first colon isn't a typical tag
                }
            } else if (llmMessageParts && llmMessageParts.length === 1) {
                currentLlmModel = llmMessageParts[0]; // Only a name, no colons
            } else {
                currentLlmModel = '';
            }
            console.log("ðŸŽ¨ updateStatus: Extracted currentLlmModel as: ", currentLlmModel);

             // Clear previous status items except the LLM selector
             const llmSelector = statusPanel.querySelector('.llm-selector-container');
             statusPanel.innerHTML = ''; // Clear
             if (llmSelector) { // Re-append selector if it exists
                  statusPanel.appendChild(llmSelector);
             }

             // Helper to create status item
             const createStatusItem = (key, valueObj) => { // Expect valueObj like {status: 'good', message: '...:'} 
                const itemDiv = document.createElement('div');
                itemDiv.className = 'status-item';

                const lightSpan = document.createElement('span');
                lightSpan.className = 'status-light status-off'; // Default to off

                let displayValue = valueObj.message || `${key}: unknown`; // Use pre-formatted message
                let statusClass = 'status-off'; // Default class

                 // Determine status class based on valueObj.status
                 switch (valueObj.status) {
                    case 'good': statusClass = 'status-good'; break;
                    case 'warning': statusClass = 'status-warning'; break;
                    case 'bad': statusClass = 'status-bad'; break;
                    default: statusClass = 'status-off'; break;
                 }
                
                 lightSpan.classList.remove('status-off'); // Remove default
                 lightSpan.classList.add(statusClass); // Add calculated class

                 const textSpan = document.createElement('span');
                 textSpan.textContent = displayValue;

                 itemDiv.appendChild(lightSpan);
                 itemDiv.appendChild(textSpan);
                 return itemDiv;
             };

             // Add status items in order, skipping the model selector container
            statusOrder.forEach(item => {
                if (statusData.hasOwnProperty(item.key)) {
                    // Skip adding llmModel as a standard status item, handle via dropdown
                    if(item.key !== 'llmModel') {
                        const statusItemElement = createStatusItem(item.name, statusData[item.key]);
                        // Insert before the selector OR just append if selector is missing (shouldn't happen)
                        statusPanel.insertBefore(statusItemElement, llmSelector || null);
                    }
                }
            });
            
            // Add metrics separately if they exist
            if (statusData.metrics) {
                const metricsOrder = [
                    { key: 'articlesInDB', name: 'Articles in DB' },
                    { key: 'llmProcessed', name: 'LLM Processed' },
                    { key: 'fallbackCount', name: 'Fallback Count' },
                    { key: 'cpuUsage', name: 'CPU Usage' },
                    { key: 'memory', name: 'Memory' }
                ];
                
                 metricsOrder.forEach(item => {
                     let metricValue = statusData.metrics[item.key];
                     let message = `${item.name}: ${metricValue !== undefined ? metricValue : 'N/A'}`;
                     let metricStatus = 'good'; // Default for metrics
                     
                     // Special handling for processed count percentage
                     if (item.key === 'llmProcessed' && statusData.metrics.processedItemCount !== undefined && statusData.metrics.articlesInDB > 0) {
                         const processedCount = statusData.metrics.processedItemCount;
                         const totalCount = statusData.metrics.articlesInDB;
                         const percentage = ((processedCount / totalCount) * 100).toFixed(1);
                         message = `LLM Processed: ${processedCount} (${percentage}%)`;
                     }
                     // Special handling for fallback count status
                     if (item.key === 'fallbackCount' && metricValue > 0) {
                         metricStatus = 'warning';
                     }
                     
                     const metricItemElement = createStatusItem(item.name, { status: metricStatus, message: message });
                     statusPanel.insertBefore(metricItemElement, llmSelector || null);
                 });
            }

            // Update the LLM dropdown selection
            if (llmModelSelect.options.length > 1 && currentLlmModel) { // Only update if models are loaded & model known
                llmModelSelect.value = currentLlmModel;
                 if (llmModelSelect.selectedIndex === -1) {
                    console.warn(`Current model '${currentLlmModel}' not found in fetched model list.`);
                 }
            }

            lastUpdatedDiv.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
        }

        // --- Function to fetch status ---
        async function fetchStatus() { 
             console.log("ðŸ“Š fetchStatus: Attempting to fetch status...");
             try {
                const response = await fetch(`${API_BASE_URL}/api/status`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log("ðŸ“Š fetchStatus: Received data:", JSON.stringify(data)); 
                updateStatus(data);
            } catch (error) {
                console.error('ðŸ“Š fetchStatus: Error fetching status:', error);
                statusPanel.innerHTML = '<div class="status-item status-bad"><span>Error fetching status</span></div>'; // Show error in panel
            }
         }

        // --- Function to Populate LLM Models ---
        async function populateLlmModels() { 
             console.log("Fetching LLM models...");
             try {
                const response = await fetch(`${API_BASE_URL}/api/status/ollama-models`); 
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const models = await response.json();

                llmModelSelect.innerHTML = ''; // Clear loading/existing options

                if (models && models.length > 0) {
                    models.forEach(model => {
                        const option = new Option(model.name, model.name);
                        llmModelSelect.add(option);
                    });
                    if(currentLlmModel) {
                       llmModelSelect.value = currentLlmModel;
                    }
                } else {
                    llmModelSelect.innerHTML = '<option value="">No models found</option>';
                }
                console.log("LLM models populated.");
            } catch (error) {
                console.error('Error fetching Ollama models:', error);
                llmModelSelect.innerHTML = '<option value="">Error loading models</option>';
            }
        }

        // --- Function to Handle LLM Model Selection ---
        async function handleModelChange() { 
             const selectedModel = llmModelSelect.value;
            if (!selectedModel || selectedModel === currentLlmModel) return;

            console.log(`Attempting to set LLM model to: ${selectedModel}`);
            try {
                const response = await fetch(`${API_BASE_URL}/api/status/set-llm-model`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ model: selectedModel })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                console.log('Model change result:', result);

                // Update UI to reflect the change
                currentLlmModel = selectedModel;
                document.getElementById('currentModel').textContent = selectedModel;

                // Refresh status to show updated model info
                fetchStatus();
            } catch (error) {
                console.error('Error changing LLM model:', error);
                alert(`Failed to change model: ${error.message}`);
            }
        }

        // --- Function to Fetch Config (Bias/Categories) ---
        async function fetchConfig() { 
             // ... (Keep implementation here) ... 
             try {
                const response = await fetch(`${API_BASE_URL}/api/sources/config`);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const config = await response.json();
                availableCategories = config.sourceCategories || availableCategories;
                availableBiases = config.biasCategories || availableBiases;
                populateSelect(sourceCategorySelect, availableCategories);
                populateSelect(sourceBiasSelect, availableBiases);
            } catch (error) {
                 console.error('Error fetching source config:', error);
                 populateSelect(sourceCategorySelect, availableCategories);
                 populateSelect(sourceBiasSelect, availableBiases);
            }
         }
         function populateSelect(selectElement, options) { 
            // Clear any existing options
            selectElement.innerHTML = ''; 
            
            // Add the default "Select..." option
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "Select...";
            defaultOption.disabled = true;
            defaultOption.selected = true;
            selectElement.appendChild(defaultOption);
            
            // Add each option from the provided array
            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option;
                selectElement.appendChild(opt);
            });
        }

        // This is the function that needs to be moved earlier
        function populateCategoryDropdown(selectElement) {
            if (!selectElement) {
                console.warn("populateCategoryDropdown: selectElement is null");
                return;
            }
            // Assuming availableCategories is a globally available array
            populateSelect(selectElement, availableCategories);
        }

        // --- Functions for Source Management ---

        // Function to update the source count display
        function updateSourceCount(count, isFiltered = false, totalCount = 0) {
            // const sourceCountSpan = document.getElementById('sourceCount'); // Already global
            if (sourceCountSpan) {
                if (isFiltered) {
                    sourceCountSpan.textContent = `${count} (Filtered / Total: ${totalCount})`;
                } else {
                    sourceCountSpan.textContent = count;
                }
            } else {
                console.warn("updateSourceCount: sourceCountSpan element not found");
            }
        }

        async function loadSources() {
            const sourcesTableBody = document.getElementById('sourcesTableBody');
            const sourceSearchInput = document.getElementById('sourceSearchInput');
            // const searchTerm = sourceSearchInput ? sourceSearchInput.value.toLowerCase() : ""; // Will be handled by filterSources

            if (!sourcesTableBody) {
                console.error("CRITICAL: sourcesTableBody element not found!");
                updateSourceCount(0);
                return;
            }
            sourcesTableBody.innerHTML = '<tr><td colspan="6" style="text-align:center;">Loading sources...</td></tr>';
            console.log("ðŸ”„ Loading sources...");

            try {
                const timestamp = Date.now(); // Prevent caching issues
                const response = await fetch(`/api/sources?_t=${timestamp}`, {
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                allSources = await response.json(); // Populate the global allSources
                console.log(`âœ… Sources loaded: ${allSources.length} items`);

                if (currentSortKey) {
                    console.log(`ðŸ”„ Re-applying sort by ${currentSortKey} (${currentSortDirection}) after loading`);
                    // Temporarily reverse direction so sortSources applies the correct one
                    const tempDirection = currentSortDirection;
                    currentSortDirection = (tempDirection === 'asc') ? 'desc' : 'asc'; 
                    sortSources(currentSortKey); // This will call renderSourcesTable
                } else {
                    renderSourcesTable(); // Render all sources if no sort key
                }
                
                // After loading sources, also refresh the category dropdown in the add/edit modal
                const categoryDropdown = document.getElementById('sourceCategory'); // For add form in modal
                if (categoryDropdown) populateCategoryDropdown(categoryDropdown);
                
                // Also for the non-modal form if it uses a different ID (assuming it's the same for now)
                // populateCategoryDropdown(document.getElementById('category'));


            } catch (error) {
                console.error('âŒ Error fetching sources:', error);
                if (sourcesTableBody) sourcesTableBody.innerHTML = `<tr><td colspan="6" class="error-message" style="text-align:center;">Error loading sources: ${error.message}</td></tr>`;
                updateSourceCount(0); // Set count to 0 on error
            }
        }

        function renderSourcesTable(sourcesToRender = allSources) { 
            const sourcesTableBody = document.getElementById('sourcesTableBody');
            if (!sourcesTableBody) {
                console.error("CRITICAL: sourcesTableBody element not found for rendering!");
                updateSourceCount(0);
                return;
            }
            console.log("ðŸ”„ Rendering sources table with", sourcesToRender.length, "sources");
            sourcesTableBody.innerHTML = ''; // Clear previous rows

            // Update header count
            const isFiltered = sourcesToRender !== allSources;
            updateSourceCount(sourcesToRender.length, isFiltered, allSources.length);

            if (sourcesToRender.length === 0) {
                sourcesTableBody.innerHTML = '<tr><td colspan="6" style="text-align:center;">No sources match search or none exist.</td></tr>';
                // updateSourceCount(0, isFiltered, allSources.length); // Already called above
                return;
            }

            sourcesToRender.forEach(source => { 
                const row = sourcesTableBody.insertRow();
                
                row.insertCell().textContent = source.name || ''; 

                const urlCell = row.insertCell();
                if (source.url) {
                    const link = document.createElement('a');
                    link.href = source.url;
                    link.textContent = source.url;
                    link.target = '_blank'; 
                    link.style.color = 'var(--primary-accent-color)';
                    urlCell.appendChild(link);
                } else {
                    urlCell.textContent = '';
                }

                const categoryCell = row.insertCell();
                const categorySelectElement = document.createElement('select');
                categorySelectElement.dataset.field = 'category';
                categorySelectElement.dataset.sourceId = source.id; // Ensure source.id is available
                const sourceCategory = (source.category || '').trim();
                categorySelectElement.dataset.originalValue = sourceCategory;
                availableCategories.forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat;
                    option.textContent = cat;
                    option.selected = (sourceCategory === cat);
                    categorySelectElement.appendChild(option);
                });
                categorySelectElement.disabled = !source.id;
                categoryCell.appendChild(categorySelectElement);

                const biasCell = row.insertCell();
                const biasSelectElement = document.createElement('select');
                biasSelectElement.dataset.field = 'bias';
                biasSelectElement.dataset.sourceId = source.id; // Ensure source.id is available
                const sourceBias = (source.bias || '').trim();
                biasSelectElement.dataset.originalValue = sourceBias;
                availableBiases.forEach(b => {
                    const option = document.createElement('option');
                    option.value = b;
                    option.textContent = b;
                    option.selected = (sourceBias === b);
                    biasSelectElement.appendChild(option);
                });
                biasSelectElement.disabled = !source.id;
                biasCell.appendChild(biasSelectElement);

                // Add the type cell
                const typeCell = row.insertCell();
                const typeSelectElement = document.createElement('select');
                typeSelectElement.dataset.field = 'type';
                typeSelectElement.dataset.sourceId = source.id;
                const sourceType = (source.type || '').trim();
                typeSelectElement.dataset.originalValue = sourceType;
                availableTypes.forEach(t => {
                    const option = document.createElement('option');
                    option.value = t;
                    option.textContent = t;
                    option.selected = (sourceType === t);
                    typeSelectElement.appendChild(option);
                });
                typeSelectElement.disabled = !source.id;
                typeCell.appendChild(typeSelectElement);

                // Modify the existing minifluxFeedId cell
                row.insertCell().textContent = source.minifluxFeedId || 'Not Synced';

                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.className = 'delete-button'; 
                if (source.id) { // Ensure source.id is available
                    deleteButton.addEventListener('click', () => deleteSource(source.id, source.name));
                } else {
                    deleteButton.disabled = true;
                    deleteButton.title = 'Cannot delete unsynced source';
                }
                actionsCell.appendChild(deleteButton);
            });
            // updateSourceCount(sourcesToRender.length, isFiltered, allSources.length); // Called at the beginning now
        }

        function filterSources() {
            const sourceSearchInput = document.getElementById('sourceSearchInput');
            console.log("ðŸ” Filtering sources with search term:", sourceSearchInput.value);
            const searchTerm = sourceSearchInput.value.toLowerCase();
            const filteredSources = allSources.filter(source => (
                (source.name || '').toLowerCase().includes(searchTerm) ||
                (source.url || '').toLowerCase().includes(searchTerm) ||
                (source.category || '').toLowerCase().includes(searchTerm) ||
                (source.bias || '').toLowerCase().includes(searchTerm) ||
                (source.type || '').toLowerCase().includes(searchTerm)
            ));
            console.log(`   Found ${filteredSources.length} sources matching search term`);
            renderSourcesTable(filteredSources); // Pass filtered sources to render
        }

        function sortSources(key) {
            console.log(`ðŸ”„ Sorting sources by ${key}`);
            const direction = (key === currentSortKey && currentSortDirection === 'asc') ? 'desc' : 'asc';
            allSources.sort((a, b) => {
                let valA = a[key] || '';
                let valB = b[key] || '';
                if (key === 'minifluxFeedId') {
                    valA = parseInt(valA, 10) || 0; // Treat non-numeric/missing as 0 for sort
                    valB = parseInt(valB, 10) || 0;
                    return direction === 'asc' ? valA - valB : valB - valA;
                }
                valA = String(valA).toLowerCase();
                valB = String(valB).toLowerCase();
                if (valA < valB) return direction === 'asc' ? -1 : 1;
                if (valA > valB) return direction === 'asc' ? 1 : -1;
                return 0;
            });
            currentSortKey = key;
            currentSortDirection = direction;
            // Update sort arrows in table headers
            document.querySelectorAll('#sourcesTable th.sortable-header .sort-arrow').forEach(arrowSpan => {
                arrowSpan.classList.remove('asc', 'desc');
                if (arrowSpan.parentElement.dataset.sortKey === key) {
                    arrowSpan.classList.add(direction);
                }
            });
            renderSourcesTable(); // Render with newly sorted allSources
        }

        async function updateSourceField(sourceId, field, value) { 
             // ... (Keep implementation here) ... 
              console.log(`â­ updateSourceField: Received sourceId: ${sourceId}, field: ${field}, value: ${value}`);
            sourceActionStatus.textContent = `Updating ${field} for source ${sourceId}...`;
            sourceActionStatus.className = '';
            try {
                const serverField = field === 'category' ? 'category' : field === 'bias' ? 'bias' : field;
                const response = await fetch(`/api/sources/${sourceId}?_t=${Date.now()}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    },
                    body: JSON.stringify({ [serverField]: value })
                });
                if (!response.ok) {
                    let errorMessage = `HTTP error! Status: ${response.status}`;
                    try {
                        const errorResult = await response.json();
                        errorMessage = errorResult.message || errorResult.error || errorMessage;
                    } catch (parseError) { console.warn("Could not parse error response as JSON."); }
                    throw new Error(errorMessage);
                }
                const result = await response.json();
                console.log(`âœ… SERVER RESPONSE: Updated source ${sourceId}, set ${serverField}="${result[serverField]}"`);
                sourceActionStatus.textContent = `Source ${result.id} ${field} updated to ${result[serverField]}.`;
                sourceActionStatus.className = 'success';
                const sourceIndex = allSources.findIndex(s => s.id === sourceId);
                if (sourceIndex > -1) {
                    console.log(`âœ… Updating allSources[${sourceIndex}].${field} from "${allSources[sourceIndex][field]}" to "${result[serverField]}"`);
                    allSources[sourceIndex][field] = result[serverField];
                } else { console.error(`âŒ Could not find source with ID ${sourceId} in allSources`); }
                return true;
            } catch (error) {
                console.error(`âŒ Error updating source ${sourceId} field ${field}:`, error);
                sourceActionStatus.textContent = `Error updating ${field}: ${error.message}`;
                sourceActionStatus.className = 'error';
                return false;
            }
          }
        async function handleAddSource(event) { 
            // ... (Keep implementation here) ... 
             event.preventDefault();
            sourceActionStatus.textContent = 'Adding source...';
            sourceActionStatus.className = '';
            addSourceButton.disabled = true;
            const formData = new FormData(addSourceForm);
            const sourceData = Object.fromEntries(formData.entries());
            try {
                const response = await fetch('/api/sources', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(sourceData)
                });
                 const result = await response.json();
                if (!response.ok) throw new Error(result.message || result.error || `HTTP error! Status: ${response.status}`);
                sourceActionStatus.textContent = `Source "${result.name}" added successfully. (Miniflux ID: ${result.miniflux_feed_id})`;
                sourceActionStatus.className = 'success';
                addSourceForm.reset();
                if(sourceModal) sourceModal.style.display = 'none'; // Close modal on success
                loadSources();
            } catch (error) {
                console.error('Error adding source:', error);
                sourceActionStatus.textContent = `Error adding source: ${error.message}`;
                 sourceActionStatus.className = 'error';
            } finally { addSourceButton.disabled = false; }
         }
        async function deleteSource(sourceId, sourceName) { 
            // ... (Keep implementation here) ... 
            if (!confirm(`Are you sure you want to delete the source "${sourceName}" (ID: ${sourceId})? This will remove it from the list and Miniflux.`)) return;
             sourceActionStatus.textContent = `Deleting source "${sourceName}"...`;
            sourceActionStatus.className = '';
            try {
                const response = await fetch(`/api/sources/${sourceId}`, { method: 'DELETE' });
                if (!response.ok) {
                     const result = await response.json().catch(() => ({}));
                    throw new Error(result.message || result.error || `HTTP error! Status: ${response.status}`);
                }
                sourceActionStatus.textContent = `Source "${sourceName}" deleted successfully.`;
                sourceActionStatus.className = 'success';
                loadSources();
            } catch (error) {
                console.error('Error deleting source:', error);
                 sourceActionStatus.textContent = `Error deleting source: ${error.message}`;
                sourceActionStatus.className = 'error';
            }
         }
         function handleFieldChange(selectElement) { 
            // ... (Keep implementation here) ... 
            console.log("ðŸ”µ handleFieldChange: Target Element:", selectElement);
            const sourceId = selectElement.dataset.sourceId;
            console.log(`ðŸ”µ handleFieldChange: Extracted sourceId: ${sourceId}`);
            const field = selectElement.dataset.field;
            const newValue = selectElement.value;
            const sourceIndex = allSources.findIndex(s => s.id === sourceId);
            if (sourceIndex === -1) {
                console.error(`âŒ Cannot handle change: Source ID ${sourceId} not found`);
                return;
            }
            const currentValueInArray = allSources[sourceIndex][field];
            console.log(`ðŸ”„ Change detected on ${sourceId}/${field} to "${newValue}". Current value: "${currentValueInArray}"`);
            if (newValue === currentValueInArray) {
                console.log(`â­ï¸ Value hasn't changed, skipping update.`);
                selectElement.dataset.originalValue = newValue;
                return;
            }
            selectElement.disabled = true;
            updateSourceField(sourceId, field, newValue)
                .then(success => {
                    if (success) {
                        selectElement.dataset.originalValue = newValue;
                        console.log(`âœ… Dataset originalValue updated for ${sourceId}/${field} to "${newValue}" AFTER success.`);
                    } else {
                        selectElement.value = currentValueInArray;
                        console.log(`âª Reverted dropdown for ${sourceId}/${field} to value: "${currentValueInArray}"`);
                    }
                })
                .finally(() => { selectElement.disabled = false; });
          }

        // --- Tag Statistics Logic ---
        async function loadTagStats() { 
            const biasStatsEl = document.getElementById('biasStats');
            const categoryStatsEl = document.getElementById('categoryStats');

            if (biasStatsEl) {
                biasStatsEl.innerHTML = '<p>Loading statistics...</p>';
            } else {
                console.error("Error: Could not find 'biasStats' element for loading message.");
            }
            if (categoryStatsEl) {
                categoryStatsEl.innerHTML = '<p>Loading statistics...</p>';
            } else {
                console.error("Error: Could not find 'categoryStats' element for loading message.");
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/status/admin/tag-stats`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const stats = await response.json();
                displayTagStats(stats);
            } catch (error) {
                console.error('Error loading tag statistics:', error);
                if (biasStatsEl) biasStatsEl.innerHTML = `<p class="error">Error loading statistics: ${error.message}</p>`;
                if (categoryStatsEl) categoryStatsEl.innerHTML = `<p class="error">Error loading statistics: ${error.message}</p>`;
            }
         }
        function displayTagStats(stats) { 
             // const tagStatsContent = document.getElementById('tagStatsContainer'); // Already global
             if (!tagStatsContent) { 
                 console.error("Error: tagStatsContainer element not found in displayTagStats"); 
                 return; 
             }

            const biasStatsEl = document.getElementById('biasStats');
            const categoryStatsEl = document.getElementById('categoryStats');

             if (!stats || typeof stats !== 'object') {
                 if (biasStatsEl) biasStatsEl.innerHTML = '<p class="error">Invalid stats format.</p>';
                 if (categoryStatsEl) categoryStatsEl.innerHTML = '<p class="error">Invalid stats format.</p>';
                 return;
             }
            
            // Update the total unique tags in the header
            if (totalUniqueTagsHeaderSpan) {
                totalUniqueTagsHeaderSpan.textContent = `(Total: ${stats.totalUniqueTags !== undefined ? stats.totalUniqueTags : '-'})`;
            }
            
            if (biasStatsEl) biasStatsEl.innerHTML = ''; // Clear previous
            if (categoryStatsEl) categoryStatsEl.innerHTML = ''; // Clear previous


            if (stats.byBias && Object.keys(stats.byBias).length > 0) {
                let biasHtml = '<ul>';
                 const biasOrder = ['Left', 'Liberal', 'Centrist', 'Unknown', 'Conservative', 'Right'];
                 biasOrder.forEach(bias => {
                     if (stats.byBias[bias] !== undefined) { biasHtml += `<li>${bias}: ${stats.byBias[bias]}</li>`; }
                 });
                 Object.entries(stats.byBias).forEach(([bias, count]) => {
                     if (!biasOrder.includes(bias)) { biasHtml += `<li>${bias}: ${count}</li>`; }
                 });
                biasHtml += '</ul>';
                if (biasStatsEl) biasStatsEl.innerHTML = biasHtml;
            } else {
                 if (biasStatsEl) biasStatsEl.innerHTML = '<p>(N/A)</p>';
            }

            if (stats.byCategory && Object.keys(stats.byCategory).length > 0) {
                let categoryHtml = '<ul>';
                Object.entries(stats.byCategory)
                    .sort(([, countA], [, countB]) => countB - countA)
                    .forEach(([category, count]) => { categoryHtml += `<li>${category}: ${count}</li>`; });
                categoryHtml += '</ul>';
                if (categoryStatsEl) categoryStatsEl.innerHTML = categoryHtml;
            } else {
                if (categoryStatsEl) categoryStatsEl.innerHTML = '<p>(N/A)</p>';
            }
         }

        // --- Functions for Database Actions ---
        async function handleDbAction(action) { 
             // ... (Keep implementation here) ...
             const buttonIdMap = { 'purge-db': 'purgeDbButton', 'force-refresh': 'forceRefreshButton', 'fix-categories': 'fixCategoriesButton' };
            const endpointMap = { 'purge-db': '/api/status/admin/purge-db', 'force-refresh': '/api/status/admin/force-refresh', 'fix-categories': '/api/sources/fix-unknown-categories' };
            const buttonId = buttonIdMap[action];
            const endpoint = endpointMap[action];
            const button = document.getElementById(buttonId);
            if (!button || !endpoint) { console.error('Invalid action:', action); return; }
            const originalText = button.textContent;
            button.disabled = true; button.textContent = 'Working...';
            purgeDbButton.disabled = true; forceRefreshButton.disabled = true; fixCategoriesButton.disabled = true;
            actionStatus.textContent = `Starting ${action}...`; actionStatus.className = '';
            try {
                const response = await fetch(endpoint, { method: 'POST' });
                const result = await response.json();
                if (!response.ok) throw new Error(result.message || `Action failed with status ${response.status}`);
                actionStatus.textContent = result.message || `${action} completed.`;
                actionStatus.className = 'success';
                fetchStatus();
                 if (action === 'fix-categories' || action === 'purge-db') { 
                     loadSources();
                     loadTagStats(); 
                 }
            } catch (error) {
                console.error(`Error during ${action}:`, error);
                actionStatus.textContent = `Error during ${action}: ${error.message}`; actionStatus.className = 'error';
            } finally {
                button.disabled = false; button.textContent = originalText;
                purgeDbButton.disabled = false; forceRefreshButton.disabled = false; fixCategoriesButton.disabled = false;
                setTimeout(() => { actionStatus.textContent = ''; }, 5000);
            }
          }

         // --- Accordion Logic --- 
         function setupAccordions() {
             document.querySelectorAll('.accordion-header').forEach(button => {
                const content = button.nextElementSibling;
                const sectionTitle = button.textContent || "";

                // Default states: Tag Stats closed, Source Management open
                if (sectionTitle.includes("Tag Statistics")) {
                    // Start closed
                    button.classList.remove('active');
                    content.classList.remove('active');
                    content.style.maxHeight = '0px';
                    content.style.paddingTop = '0';
                    content.style.paddingBottom = '0';
                } else { // For Source Management and any others, start open
                    button.classList.add('active');
                    content.classList.add('active');
                    content.style.maxHeight = 'none'; 
                    content.style.paddingTop = "var(--padding-normal)";
                    content.style.paddingBottom = "var(--padding-normal)";
                }

                // Add click listener for subsequent interactions
                 button.addEventListener('click', () => {
                     button.classList.toggle('active');
                     content.classList.toggle('active');
                     if (content.classList.contains('active')) {
                         content.style.maxHeight = 'none'; 
                         const scrollHeight = content.scrollHeight;
                         content.style.maxHeight = '0'; 
                         setTimeout(() => { 
                             content.style.maxHeight = scrollHeight + "px"; 
                             content.style.paddingTop = "var(--padding-normal)";
                             content.style.paddingBottom = "var(--padding-normal)";
                         }, 10);
                     } else {
                         content.style.maxHeight = '0px';
                         content.style.paddingTop = '0';
                         content.style.paddingBottom = '0';
                     }
                 });
             });
          }
          
         // --- Debug Tools --- 
         function setupDebugTools() {
             document.getElementById('debugUpdateBtn')?.addEventListener('click', async () => { /* ... */ });
             document.getElementById('debugGetSourceBtn')?.addEventListener('click', async () => { /* ... */ });
             document.getElementById('debugReloadBtn')?.addEventListener('click', async () => { /* ... */ });
             // Keep implementation for debug buttons here
              document.getElementById('debugUpdateBtn')?.addEventListener('click', async () => {
                  const debugOutput = document.getElementById('debugOutput');
                  const sourceId = document.getElementById('debugSourceId').value.trim();
                  const field = document.getElementById('debugField').value;
                  const value = document.getElementById('debugValue').value.trim();
                  if (!sourceId || !value) { debugOutput.innerHTML = '<p style="color: var(--error-color);">âš ï¸ Enter Source ID and value</p>'; return; }
                  debugOutput.innerHTML = `<p>Sending update for source ${sourceId}...</p>`;
                  try {
                      const updateResponse = await fetch(`/api/sources/${sourceId}?_t=${Date.now()}`, { method: 'PUT', headers: { 'Content-Type': 'application/json', 'Cache-Control': 'no-cache' }, body: JSON.stringify({ [field]: value }) });
                      const updateData = await updateResponse.json();
                      if (!updateResponse.ok) throw new Error(updateData.message || `Status: ${updateResponse.status}`);
                      debugOutput.innerHTML += `<p style="color: var(--accent-color);">âœ… Server response: ${JSON.stringify(updateData)}</p>`;
                      const verifyResponse = await fetch(`/api/sources/${sourceId}?_t=${Date.now()}`, { headers: { 'Cache-Control': 'no-cache' }});
                      if (!verifyResponse.ok) throw new Error(`Failed to verify: ${verifyResponse.status}`);
                      const verifyData = await verifyResponse.json();
                      debugOutput.innerHTML += `<p>ðŸ” Verification: ${JSON.stringify(verifyData)}</p>`;
                      debugOutput.innerHTML += `<p style="color: ${verifyData[field] === value ? 'var(--accent-color)' : 'var(--error-color)'}">
                          Result: ${verifyData[field] === value ? 'SUCCESS' : 'FAILED'}
                      </p>`;
                  } catch (error) { debugOutput.innerHTML += `<p style="color: var(--error-color);">âŒ Error: ${error.message}</p>`; }
              });
              document.getElementById('debugGetSourceBtn')?.addEventListener('click', async () => {
                  const debugOutput = document.getElementById('debugOutput');
                  const sourceId = document.getElementById('debugSourceId').value.trim();
                  if (!sourceId) { debugOutput.innerHTML = '<p style="color: var(--error-color);">âš ï¸ Enter Source ID</p>'; return; }
                  debugOutput.innerHTML = `<p>Fetching source ${sourceId}...</p>`;
                  try {
                      const response = await fetch(`/api/sources/${sourceId}?_t=${Date.now()}`, { headers: { 'Cache-Control': 'no-cache' }});
                      if (!response.ok) throw new Error(`Failed to get: ${response.status}`);
                      const data = await response.json();
                      debugOutput.innerHTML += `<p>ðŸ“„ Data: ${JSON.stringify(data)}</p>`;
                  } catch (error) { debugOutput.innerHTML += `<p style="color: var(--error-color);">âŒ Error: ${error.message}</p>`; }
              });
               document.getElementById('debugReloadBtn')?.addEventListener('click', async () => {
                  const debugOutput = document.getElementById('debugOutput');
                  debugOutput.innerHTML = '<p>Forcing reload...</p>';
                  try {
                      await loadSources();
                      debugOutput.innerHTML += '<p style="color: var(--accent-color);">âœ… Sources reloaded</p>';
                      debugOutput.innerHTML += `<p>ðŸ“Š Count: ${allSources.length}</p>`;
                      if (allSources.length > 0) {
                          debugOutput.innerHTML += '<p>Sample:</p>';
                          allSources.slice(0, 3).forEach(s => { debugOutput.innerHTML += `<p>${s.id}: ${s.name}</p>`; });
                      }
                  } catch (error) { debugOutput.innerHTML += `<p style="color: var(--error-color);">âŒ Error: ${error.message}</p>`; }
              });
         }

        // --- DOMContentLoaded Listener (Initial Calls & Event Bindings) ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("ðŸš€ DOM fully loaded. Initializing admin page...");

            // Setup Accordions - will now open them by default
            setupAccordions();

            // Setup Debug Tools
            // setupDebugTools(); // Assuming this might be optional or added later

            // Initial Data Fetches
            loadSourceConfig()
                .then(() => loadSources()) 
                .catch(error => console.error("Error in initial config/source fetch:", error));

            fetchStatus(); // Fetch initial status
            populateLlmModels(); // Fetch LLM models
            loadTagStats(); // Fetch initial tag stats

            connectLogStream(); // Initialize log stream connection

            // Setup Periodic Refresh
            setInterval(fetchStatus, 10000); // Refresh status every 10s
            setInterval(loadTagStats, 30000); // Refresh tags every 30s

            // Setup Event Listeners
            addSourceForm?.addEventListener('submit', handleAddSource);
            sourceSearchInput?.addEventListener('input', filterSources);
            llmModelSelect?.addEventListener('change', handleModelChange);
            sourcesList?.addEventListener('change', (event) => { // Delegated listener
                if (event.target.tagName === 'SELECT' && event.target.dataset.sourceId && event.target.dataset.field) {
                    handleFieldChange(event.target);
                }
            });
             document.querySelectorAll('#sourcesTable th.sortable-header').forEach(headerCell => { // Corrected selector for sortable headers in the table
                 headerCell.addEventListener('click', () => sortSources(headerCell.dataset.sortKey));
             });
             purgeDbButton?.addEventListener('click', () => { if (confirm('Are you SURE? This will delete ALL news items!')) { handleDbAction('purge-db'); } });
             forceRefreshButton?.addEventListener('click', () => handleDbAction('force-refresh'));
             fixCategoriesButton?.addEventListener('click', () => { if (confirm('Fix categories?')) { handleDbAction('fix-categories'); } });

            // Modal Event Listeners
            showAddSourceModalButton?.addEventListener('click', () => {
                if (sourceModal) {
                    sourceModal.style.display = 'block';
                    if (modalTitle) modalTitle.textContent = 'Add New Source';
                    addSourceForm.reset(); // Reset form fields
                    if(document.getElementById('sourceId')) document.getElementById('sourceId').value = ''; // Clear hidden ID
                    if (modalError) modalError.textContent = ''; // Clear any previous error messages
                }
            });

            closeModalButton?.addEventListener('click', () => {
                if (sourceModal) {
                    sourceModal.style.display = 'none';
                }
            });

            window.addEventListener('click', (event) => {
                if (event.target === sourceModal) {
                    sourceModal.style.display = 'none';
                }
            });

            // Import/Export Buttons
            const exportBtn = document.getElementById('exportSourcesBtn');
            if(exportBtn) {
                exportBtn.addEventListener('click', exportSources);
            }

            const importBtn = document.getElementById('importSourcesBtn');
            const importFileInput = document.getElementById('importFile');
            if(importBtn && importFileInput) {
                // Trigger file input click when "Import Sources" button is clicked
                importBtn.addEventListener('click', () => importFileInput.click()); 
                // Handle file selection
                importFileInput.addEventListener('change', importSourcesFromFile);
            }

            const purgeSourcesBtn = document.getElementById('purgeSourcesDbBtn');
            if (purgeSourcesBtn) {
                purgeSourcesBtn.addEventListener('click', handlePurgeAllSources);
            }

        });

        // --- Import/Export Sources ---
        async function exportSources() {
            const statusDiv = document.getElementById('importExportStatus');
            statusDiv.textContent = 'Exporting sources...';
            statusDiv.className = 'status-message info';
            try {
                const response = await fetch('/api/sources/export');
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: 'Failed to export sources. Unknown error.' }));
                    throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                }
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'sources_export.json';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                statusDiv.textContent = 'Sources exported successfully.';
                statusDiv.className = 'status-message success';
            } catch (error) {
                console.error('Error exporting sources:', error);
                statusDiv.textContent = `Error exporting sources: ${error.message}`;
                statusDiv.className = 'status-message error';
            }
        }

        async function importSourcesFromFile() {
            const statusDiv = document.getElementById('importExportStatus'); // Correct ID for status
            const fileInput = document.getElementById('importFile');
            
            if (!fileInput.files || fileInput.files.length === 0) {
                statusDiv.textContent = 'Please select a JSON file to import.';
                statusDiv.className = 'status-message error';
                return;
            }
            
            const file = fileInput.files[0];
            if (file.type !== 'application/json') {
                statusDiv.textContent = 'Invalid file type. Please select a JSON file.';
                statusDiv.className = 'status-message error';
                return;
            }

            statusDiv.textContent = 'Importing sources...'; // Initial message
            statusDiv.className = 'status-message info'; // Using 'info' for pending

            const formData = new FormData();
            // Backend expects 'sourcesFile' as per multer setup in sourceRoutes.js
            // Make sure your multer field name matches this in sourceRoutes.js `upload.single('sourcesFile')`
            formData.append('sourcesFile', file); // Corrected back to 'sourcesFile' to match backend multer config

            let importSucceededFully = false;

            try {
                const response = await fetch('/api/sources/import', {
                    method: 'POST',
                    body: formData
                    // Headers are not explicitly set for FormData; browser does it.
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.message || `HTTP error! status: ${response.status}`);
                }
                
                let summaryHtml = `Import Complete: <br>Added: ${result.added}, Skipped: ${result.skipped}, Errors: ${result.errors}<br>`;
                if (result.details && result.details.length > 0) {
                    summaryHtml += 'Details:<ul>';
                    result.details.forEach(detail => {
                        summaryHtml += `<li>${detail.name || 'Unnamed Source'}: ${detail.status} - ${detail.message}</li>`;
                    });
                    summaryHtml += '</ul>';
                }
                statusDiv.innerHTML = summaryHtml;
                
                if (result.errors > 0 || (result.skipped > 0 && result.added === 0 && result.errors === 0) ) {
                     statusDiv.className = 'status-message error';
                } else if (result.skipped > 0) {
                     statusDiv.className = 'status-message warning';
                } else {
                     statusDiv.className = 'status-message success';
                     importSucceededFully = true;
                }
                
                loadSources(); 
                loadTagStats();

            } catch (error) {
                console.error('Error importing sources:', error);
                statusDiv.textContent = `Error importing sources: ${error.message}`;
                statusDiv.className = 'status-message error';
            } finally {
                // Clear the file input for next use
                fileInput.value = ''; 
                // Optional: Clear status message after a delay if it wasn't a full success or explicit error
                // if (!importSucceededFully && !statusDiv.classList.contains('error') && !statusDiv.classList.contains('warning')) {
                //    setTimeout(() => { 
                //        if (statusDiv.textContent.startsWith("Importing sources...")) { // Only clear if it's still the pending message
                //             statusDiv.textContent = 'Import operation finished.'; 
                //             statusDiv.className = 'status-message info';
                //        }
                //    }, 5000);
                // } else if (importSucceededFully) {
                //     setTimeout(() => { statusDiv.textContent = ''; statusDiv.className = 'status-message'; }, 7000);
                // }
            }
        }

        // --- Function to Handle Purging All Sources ---
        async function handlePurgeAllSources() {
            const statusDiv = document.getElementById('importExportStatus'); // Reuse status div for messages
            if (!confirm("DANGER ZONE! Are you absolutely sure you want to delete ALL sources from the database AND attempt to remove them from Miniflux? This action cannot be undone.")) {
                return;
            }
            if (!confirm("REALLY DANGER ZONE! Second confirmation: This will wipe your sources. Proceed?")) {
                return;
            }

            statusDiv.textContent = 'Purging all sources... This may take a moment.';
            statusDiv.className = 'status-message warning'; // Use warning class for in-progress

            try {
                const response = await fetch('/api/sources/purge-all', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.message || `HTTP error! status: ${response.status}`);
                }
                statusDiv.textContent = result.message || 'All sources purged successfully.';
                statusDiv.className = 'status-message success';
                loadSources(); // Refresh the source list (should be empty)
                loadTagStats(); // Refresh stats
            } catch (error) {
                console.error('Error purging all sources:', error);
                statusDiv.textContent = `Error purging sources: ${error.message}`;
                statusDiv.className = 'status-message error';
            }
        }

        async function loadSourceConfig() {
            try {
                console.log("ðŸ”„ Loading source config (categories, biases, etc)...");
                const response = await fetch(`${API_BASE_URL}/api/sources/config`);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const config = await response.json();
                console.log("âœ… Source config loaded:", config);
                
                // Populate global availableCategories from config
                availableCategories = config.sourceCategories || [];
                console.log(`   Found ${availableCategories.length} source categories`);
                
                // Populate global availableBiases from config
                availableBiases = config.biasCategories || [];
                console.log(`   Found ${availableBiases.length} bias categories`);
                
                // Populate global availableTypes - use the config if available, otherwise use hardcoded values
                if (config.sourceTypes && config.sourceTypes.length > 0) {
                    availableTypes = config.sourceTypes;
                    console.log(`   Found ${availableTypes.length} source types from API`);
                } else {
                    console.log(`   Using hardcoded source types: ${availableTypes.join(', ')}`);
                }
                
                // Populate dropdowns in add source form
                const sourceCategorySelect = document.getElementById('sourceCategory');
                const sourceBiasSelect = document.getElementById('sourceBias');
                const sourceTypeSelect = document.getElementById('sourceType');
                
                if (sourceCategorySelect) {
                    populateSelect(sourceCategorySelect, availableCategories);
                }
                
                if (sourceBiasSelect) {
                    populateSelect(sourceBiasSelect, availableBiases);
                }
                
                if (sourceTypeSelect) {
                    populateSelect(sourceTypeSelect, availableTypes);
                }
            } catch (error) {
                console.error("âŒ Error loading source config:", error);
                
                // In case of error, use hardcoded values and populate dropdowns
                const sourceCategorySelect = document.getElementById('sourceCategory');
                const sourceBiasSelect = document.getElementById('sourceBias');
                const sourceTypeSelect = document.getElementById('sourceType');
                
                if (sourceCategorySelect) {
                    populateSelect(sourceCategorySelect, availableCategories);
                }
                
                if (sourceBiasSelect) {
                    populateSelect(sourceBiasSelect, availableBiases);
                }
                
                if (sourceTypeSelect) {
                    populateSelect(sourceTypeSelect, availableTypes);
                    console.log("   Populated source type dropdown with hardcoded values as fallback");
                }
            }
        }

    </script>
</body>
</html> 