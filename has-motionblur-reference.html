<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion Blur Effect</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        // Core settings
        const SETTINGS = {
            numObjects: 4,
            objectSize: 0.4,
            ringRadius: 3,
            numTrails: 52,
            fadeOutRate: 0.018,
            baseOpacity: 0.18,
            rotationSmoothing: 0.05
        };

        // State
        const state = {
            mouse: { x: 0, y: 0 },
            rotation: { 
                target: { x: 0, y: 0 },
                current: { x: 0, y: 0 }
            },
            movement: {
                active: false,
                amount: 0
            }
        };

        // Initialize scene
        function init() {
            camera.position.z = 5;
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
        }

        // Ring management
        let ringGroup = new THREE.Group();
        let trails = [];
        let objects = [];
        const colors = [
            0xFF5733, 0x33FF57, 0x3357FF, 0xF3FF33
        ];

        function createRing() {
            // Cleanup
            scene.remove(ringGroup);
            trails.forEach(trail => scene.remove(trail.group));
            
            // Setup
            ringGroup = new THREE.Group();
            trails = [];
            objects = [];
            
            // Create trails
            for (let t = 0; t < SETTINGS.numTrails; t++) {
                const trailGroup = new THREE.Group();
                trailGroup.renderOrder = -10 - t;
                scene.add(trailGroup);
                trails.push({ group: trailGroup, delay: t * 2 });
            }
            
            // Create objects
            for (let i = 0; i < SETTINGS.numObjects; i++) {
                const angle = (i / SETTINGS.numObjects) * Math.PI * 2;
                const geometry = new THREE.PlaneGeometry(SETTINGS.objectSize, SETTINGS.objectSize);
                
                // Material setup
                const material = new THREE.MeshBasicMaterial({ 
                    color: colors[i],
                    side: THREE.DoubleSide 
                });
                
                // Create and position mesh
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    Math.cos(angle) * SETTINGS.ringRadius,
                    Math.sin(angle) * SETTINGS.ringRadius,
                    0.1
                );
                mesh.renderOrder = 10;
                mesh.userData = { angle };
                mesh.lookAt(camera.position);
                
                ringGroup.add(mesh);
                objects.push(mesh);
                
                // Create trails with the same color
                trails.forEach((trail, t) => {
                    const trailMaterial = new THREE.MeshBasicMaterial({
                        color: colors[i],
                        transparent: true,
                        opacity: 0,
                        side: THREE.DoubleSide,
                        depthTest: true
                    });
                    
                    const trailMesh = new THREE.Mesh(geometry.clone(), trailMaterial);
                    trailMesh.position.copy(mesh.position);
                    trailMesh.lookAt(camera.position);
                    trail.group.add(trailMesh);
                });
            }
            
            scene.add(ringGroup);
        }

        // Animation
        const positionHistory = [];
        
        function updateTrails() {
            if (state.movement.active) {
                state.movement.amount = Math.min(1.0, state.movement.amount + 0.05);
            } else if (state.movement.amount > 0) {
                state.movement.amount = Math.max(0, state.movement.amount - 0.02);
            }
            
            positionHistory.unshift({
                x: state.rotation.current.x,
                y: state.rotation.current.y
            });
            
            if (positionHistory.length > 1000) positionHistory.pop();
            
            trails.forEach((trail, index) => {
                const historyPos = positionHistory[trail.delay];
                if (historyPos) {
                    trail.group.rotation.x = historyPos.x;
                    trail.group.rotation.y = historyPos.y;
                    
                    const opacity = state.movement.active 
                        ? Math.max(0.01, (SETTINGS.baseOpacity - (index * SETTINGS.fadeOutRate)) * state.movement.amount)
                        : 0;
                        
                    trail.group.children.forEach((mesh, meshIndex) => {
                        // Get corresponding main object
                        const objectIndex = meshIndex % objects.length;
                        const obj = objects[objectIndex];
                        
                        if (obj) {
                            // Copy rotation from main object
                            mesh.quaternion.copy(obj.quaternion);
                            
                            // Calculate direction from camera to object
                            const cameraToObjectDir = new THREE.Vector3()
                                .subVectors(obj.position, camera.position)
                                .normalize();
                            
                            // Position trail behind object with increasing offset
                            const offset = 0.05 + (index * 0.02);
                            mesh.position.copy(obj.position);
                            mesh.position.add(cameraToObjectDir.multiplyScalar(offset));
                            
                            // Update opacity
                            mesh.material.opacity = opacity;
                        }
                    });
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Update rotation
            state.rotation.current.x += (state.rotation.target.x - state.rotation.current.x) * SETTINGS.rotationSmoothing;
            state.rotation.current.y += (state.rotation.target.y - state.rotation.current.y) * SETTINGS.rotationSmoothing;
            
            ringGroup.rotation.x = state.rotation.current.x;
            ringGroup.rotation.y = state.rotation.current.y;
            
            updateTrails();
            
            objects.forEach(obj => obj.lookAt(camera.position));
            trails.forEach(trail => {
                trail.group.children.forEach(mesh => mesh.lookAt(camera.position));
            });
            
            renderer.render(scene, camera);
        }

        // Event handlers
        function onMouseMove(event) {
            const newX = (event.clientX / window.innerWidth) * 2 - 1;
            const newY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            if (Math.abs(newX - state.mouse.x) + Math.abs(newY - state.mouse.y) > 0.001) {
                state.movement.active = true;
            } else {
                state.movement.active = false;
            }
            
            state.mouse.x = newX;
            state.mouse.y = newY;
            
            state.rotation.target.x = state.mouse.y * 1.5;
            state.rotation.target.y = state.mouse.x * 1.5;
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Initialize
        init();
        createRing();
        animate();

        // Event listeners
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('resize', onResize);
    </script>
</body>
</html>
